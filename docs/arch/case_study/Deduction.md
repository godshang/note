# 如何设计一个扣减类服务

## 什么是扣减类业务

我们长见到各类秒杀系统设计的文章，但是秒杀只是扣减类业务中一个有代表性、具备一定技术复杂度的场景，它并不代表扣减类业务的全部场景。

常见的扣减类业务有：

* 购买一个或多个商品时扣减库存
* 商家针对用户设置的某个或几个商品最多购买次数
* 支付订单时扣减的金额
* ......

上述业务场景有几个共性点：购买的或设置需要构建的数量一次可以是一个或多个，数量是共享的，每个用户可以扣减某一个数据的数量。基于上述分析，可以给构建业务下一个定义：

>它是需要通过对一个或多个已有的、用户间或用户内共享的数量，精准扣减成功才能继续的业务。

通过定义，将我们要讨论的扣减业务圈定了一个边界和清晰的概念。

在了解了扣减类业务的定义之后，再来看看它和前面几个模块中涉及的读业务与 UGC 写业务的区别。

* 读业务的特点是写少读多，同时写入为非在线类运营操作，写入的 SLA（Service Level Agreement，服务等级协议）要求级别较低，对于读的 SLA 最高。读数据因为不会改或者频率很低，所以可以采用数据不断前置应对性能等的要求。
* UGC 写业务则和扣减业务类似。写入均是 C 端（客户）操作，对写入的 SLA 要求级别最高。但 UGC 写业务的特点是写入的数据是用户私有的而不是共享的，同时写入不需要依赖已有的数据。对于 UGC 写业务，只要尽最大可能将数据存储下来即可。

相比上两类业务的各自特点与技术实现关注点，扣减类业务着重关注对历史已有数据的增减上，接下来我们就来具体看一看对扣减类业务的特点如何应对。

## 扣减类业务的技术关注点

发生扣减必然就会存在归还。比如用户购买了商品之后因为一些原因想要退货，这个时候就需要将商品的库存、商品设置的购买次数及订单金额等进行归还。因此，在实现的时候还需要考虑归还。但是因归还的实现较通用，且归还是后置流程对并发性要求并不高。

关于扣减的实现，需要关注的技术点总结如下：

* 当前剩余的数量需要大于等于当次需要扣减的数量，即不允许超卖；
* 对同一个数据的数量存在用户并发扣减，需要保证并发一致性；
* 需要保证可用性和性能，性能至少是秒级；
* 一次的扣减会包含多个目标数量；
* 当次扣减有多个数量时，其中一个扣减不成功即不成功，需要回滚。

对于返还的实现需要关注的技术点如下：

* 必须有扣减才能返还；
* 返还的数量必须要加回，不能丢失；
* 返还的数据总量不能大于扣减的总量；
* 一次扣减可以有多次返还；
* 返还需要保证幂等。

下面介绍三种不同方式的实现方案。这三个方案都能够满足上述要求的功能和对应的技术点要求，但三个方案的实现复杂度以及能够支撑的性能和并发量级均有一定的区别。

## 纯数据库式扣减实现

顾名思义，纯数据库的方案就是扣减业务的实现完全依赖数据库提供的各项功能，而不依赖其他额外的一些存储和中间件了。纯数据库实现的好处是逻辑简单、开发及部署成本低。

纯数据库的实现之所以能够满足扣减业务的各项功能要求，主要是依赖各类主流数据库提供的两个特性：

* 第一是基于数据库乐观锁的方式保证数据并发扣减的强一致性；
* 第二是基于数据库的事务实现批量扣减部分失败时的数据回滚。

基于上述特性实现的架构方案包含一个扣减服务和一个数量数据库。

<img src="./image/Cgp9HWApcLGAA14FAAEV09SPPKc433.png" />

数量数据库存储扣减中的所有数据，主要包含两张表：扣减剩余数量表和流水表。扣减剩余数量表是最主要的表，包含实时的剩余数量。

| 字段名          | 英文表示 | 含义         |
| ------------------ | ------------ | -------------- |
| 商品ID           | SKU          | 商品标识   |
| 当前剩余可购买数量 | LeavedAmount | 剩余可购买数量 |

如上表所示，对于当前剩余可购买的数量，当用户进行取消订单、售后等场景时，都需要把数量加回到此字段。同时，当商家补齐库存时，也需要把数量加回。

从完成业务功能的角度看，只要扣减剩余数量表即可。但在实际场景中，会需要查看明细进行对账、盘货、排查问题等需求。其次，在扣减后需要进行返还时是非常依赖流水的。因为只能返还有扣减记录的库存数量。最后，在技术上的幂等性，也非常依赖流水表。

| 字段名    | 英文表示 | 含义                         |
| ------------ | -------- | ------------------------------ |
| 扣减编号 | UUID     | 表示一次成功的扣减记录 |
| 商品ID     | SKU      | 商品ID                       |
| 此次扣减数量 | num      | 此次扣减服务扣减对应商品的数量 |

### 扣减接口的实现

扣减接口接受用户提交的扣减请求，包含用户账号、一批商品及对应的购买数量，大致实现逻辑如下图所示：

<img src="./image/Cgp9HWApcOmAJUgzAAFb9E3dPqI312.png" />

流程开始时，首先进行的是数据校验，在其中可以做一些常规的参数格式校验。其次，它还可以进行库存扣减的前置校验。比如当数据库中库存只有 8 个时，而用户要购买 10 个，此时在数据校验中即可前置拦截，减少对于数据库的写操作。纯读不会加锁，性能较高，可以采用此种方式提升并发量。

当用户只购买某商品 2 个时，如果在校验时剩余库存有 8 个，此时校验会通过。但在后续的实际扣减时，因为其他用户也在并发的扣减，可能会出现此用户实际去扣减时不足 2 个，导致失败。这种场景就会导致多一次数据库查询，降低了整体的扣减性能。其次，即使将校验放置在事务内，先查询数据库数量校验通过后再扣减，也会增加性能。

那是不是前置校验就不需要了呢？在实践中，前置校验是需要的。相比读，扣减的事务性能更差，两弊相衡取其轻，能避免则避免。此外，扣减服务提供的数量查询接口和校验中的反查底层实现是相同的，如果反查走库则都走库。

在事务之后，则是数据库更新操作。因为用户扣减的商品数量可以是一个或多个，只要其中一个扣减不成功，则判定用户不能购买。注意，因为在事务之后，对商品使用 for 循环进行处理，每一次循环都需要判断结果。如果一个扣减失败，则进行事务回滚。基于上述提供的两张表结构，单条商品的扣减 SQL 大致如下：

```
update stock set leavedAmount=leavedAmount-currentAmount where skuid='123456' and leavedAmount>=currentAmount
```

此 SQL 采用了类似乐观锁的方式实现了原子性，在 where 条件里判断此次需要的数量小于等于剩余的数量。在扣减服务的代码里，判断此 SQL 的返回值，如果值为 1 表示扣减成功，即用户此次购买的数量，当前的库存可以满足否则，返回 0 进行回滚即可。

扣减完成之后，需要记录流水数据。每一次扣减时，都需要外部用户传入一个 uuid 作为流水编号，此编号是全局唯一的。用户在扣减时传入唯一的编号有两个作用。

1. 当用户归还数量时，需要带回此编号，用来标识此次返还属于历史上的具体哪次扣减。
2. 进行幂等性控制。当用户调用扣减接口出现超时时，因为用户不知道是否成功，用户可以采用此编号进行重试或反查。在重试时，使用此编号进行标识防重。

当每一个 SKU 按上述流程都扣减成功了，则提交事务，说明整个扣减成功。

### 扣减接口实现升级

在上面提到了前置校验的好处及存在的问题：多一次查询，就会增加数据库的压力，同时对整体服务性能也有一定影响。此外，对外提供的查询库存数量的接口也会对数据库产生压力，同时读的请求量要远大于写，由此带来的压力会更大。

根据业务场景分析，读库存的请求一般是顾客浏览商品时产生，而调用扣减库存的请求基本上是用户购买时才会触发。用户购买请求的业务价值相比读请求会更大，因此对于写需要重点保障。转换到技术上，价值相对低的读来说是可以降级的、有损的。对于写要尽可能性能好、尽量减少不必要的读与写请求（写本身非常消耗性能）等。

针对上述的问题，可以对整体架构进行升级，整体的升级策略采用了读写分离的方式，另外主从复制直接使用了 MySQL 等数据库已有功能，改动上非常小，只要在扣减服务里配置两个数据源。当客户查询剩余库存数量、扣减服务中的前置校验时，读取从数据库即可。而真正的数据扣减还是使用主数据库。

<img src="./image/Cgp9HWApcPuAcMC5AAFXGYoBi64806.png" />

读写分离之后，根据二八原则，80% 的均为读流量，主库的压力降低了 80%。但采用了读写分离也会导致读取的数据不准确的问题，不过库存数量本身就在实时变化，短暂的差异业务上是可以容忍的，最终的实际扣减会保证数据的准确性。

不过，在上面提到的因为在扣减前，为了降低数据库的压力，增加的前置校验导致的性能下降问题，并没有得到太多实质性的升级解决。那么，接下来我们该从什么方向上解决这个问题呢？

### 扣减接口实现再升级

在基于数据库的主从复制降低了主库流量压力之后，还需要升级的就是读取的性能了。可以采用 Binlog 实现简单、可靠的异构数据同步。

<img src="./image/CioPOWApcQ6AUK4xAAHzcrHHvOU268.png" />

经过此次方案升级后，基本上解决了在前置扣减里校验环节及获取库存数量接口的性能问题，提高了用户体验性。

### 纯数据库扣减方案适用性

纯数据库方案主要有以下几个优点：

* 实现简单，即使读使用了前置缓存，整体代码工程就两个，即扣减服务与数据映射服务，在需求交付周期非常短、人力紧张的场景是非常适用的；
* 使用了数据库的 ACID 特性进行扣减。业务上，库存数量既不会出现超卖，也不会出现少卖。

但不足之处是，当扣减 SKU 数量增多时，性能非常差。因为对每一个 SKU 都需要单独扣减，导致事务非常大，极端情况下，可能出现几十秒的情况。

## 纯缓存方式扣减实现

纯数据库的方案虽然避免了超卖与少卖的情况，但因采用了事务的方式保证一致性和原子性，所以在 SKU 数量较多时性能下降较明显。

因为扣减有一个要求即当一个 SKU 购买的数量不够时，整个批量扣减就要回滚，因此，我们需要使用类似 for 循环的方式对每一个扣减 SQL 的返回值进行检查。另外一个原因是，当多个用户买一个 SKU 时，它的性能也并不乐观。因为当出现高并发扣减或者并发扣减同一个 SKU 时，事务的隔离性会导致加锁等待以及死锁情况出现。

实际上，扣减并不需要数据库提供的ACID属性，只需要保证原子性即可，可以考虑使用Redis来替代数据库。Redis 采用了单线程的事件模型，保障了我们对于原子性的要求。对于单线程的事件模型，简单的比喻就是说当我们多个客户端给 Redis 同时发送命令后，Redis 会按接收到的顺序进行串行的执行，对于已经接收而未能执行的命令，只能排队等待。基于此特性，当我们的扣减请求在 Redis 执行时，也即是原子性的。此特性刚好符合我们对于扣减原子性的要求。

在确定了使用缓存来完成扣减和高性能后，可以得到如下的扣减服务架构图。

<img src="./image/Cgp9HWAtA_uACYzfAAFu1pwsXwI292.png" />

缓存中存储的信息和上一讲中的数据库表结构基本类似，包含当前商品和剩余的库存数量和当次的扣减流水，这里要注意两点。

* 首先，因为扣减全部依赖于缓存不依赖数据库，所有存储于 Redis 的数据均不设置过期并全量存储。
* 其次，Redis 是以 k-v 结构为主，伴随 hash、set 等结构，与 MySQL 以表 + 行为主的结构有一定的差异。

Redis 中的库存数量结构大致如下：

```
key为：sku_stock_{sku}。前缀sku_stock是固定不变，所有以此为前缀的均表示是库存。{sku}是占位符，在实际存储时被具体的skuid替代。
value:库存数量。当前此key表示的sku剩余可购买的数量。
```

在实际应用中，上述 key 的 sku_stock_ 前缀一般会简写成 ss_ 或者可以起到和其他 key 区分的较短形式。当我们存储的 SKU 有百万、千万级别时，此方式可极大地降低存储空间，从而降低成本，毕竟内存是比较昂贵的。

对于 Redis 中存储的流水表采用 hash 结构，即 key + hashField + hashValue 的形式。结构大致如下：

```
key：sx_{sku}。前缀sx_是按上述缩短的形式设计的，只起到了区分的作用。{sku}为占位符
hashField：此次扣减流水编号。
hashValue: 此次扣减的数量
```

在一次扣减时，会按 SKU 在 Redis 中先扣减完库存数量再记录流水信息。

**注意**，扣减接口支持一次扣减多个 SKU + 数量，但是Redis 对于 hash 结构不支持多个 key 的批量操作，而且Redis 对于不同数据结构间不支持批量操作，比如 KV 与 Hash 间。

如果对于多个 SKU 不支持批量操作，我们就需要按单个 SKU 发起 Redis 调用。在上文中提到过，Redis 不对命令间保证单线程执行。如果采用上述 Redis 的数据结构，一次扣减必须要发起多次对 Redis 的命令才可完成。这样，上文提到的利用 Redis 单线程来保证扣减的原子性此时则满足不了了。

针对上述问题，我们可以采用 Redis 的 lua 脚本来实现批量扣减的单线程诉求。

Redis 中的 lua 脚本执行时，首先会使用 get 命令查询 uuid 是否已存在，如已存在则直接返回，并提示用户请求重复。当防重通过后，会按 SKU 批量获取对应的剩余库存状态并进行判断，如果其中一个 SKU 此次扣减的数量大于剩余数量，则直接给扣减服务返回错误并提示数量不足。通过 Redis 的单线程模型，确保当所有 SKU 的扣减数量在判断均满足后，在实际扣减时，数量不够的情况是不会出现的。同时，单线程保证判断数量的步骤和后续扣减步骤之间，没有其他任何线程出现并发的执行。

判断数量满足之后，lua 脚本后续就可以按 SKU 进行循环的扣减数量并记录流水。

当 Redis 扣减成功后，扣减接口会异步的将此次扣减内容保存至数据库。异步保存数据库的目的是防止出现极端情况—— Redis 宕机后数据未持久化到磁盘，此时我们可以使用数据库恢复或者校准数据。

最后，在纯缓存的架构图（图 2）中还有一个运营后台，它直接连接了数据库，是运营和商家修改库存的入口。当商品补齐了新的货物时，商家在运营后台将此 SKU 库存数量加回。同时，运营后台的实现需要将此数量同步的增加至 Redis，因为当前方案的所有实际扣减都在 Redis 中。

至此，采用纯缓存扣减的基本方案已经介绍结束了。因为实际的压测和很多因素相关，比如机器配置、压测的参数等，此处就不给出具体数字。但目前这个方案已经可以满足支撑单机万级的扣减了。下面我们再来看一看如何应对异常情况。

### 异常情况分析

因为 Redis 不支持 ACID 特性，导致在使用 Redis 进行扣减时相比纯数据库方案有较多异常场景需要处理。

**第一个场景是 Redis 突然宕机的场景**

如果 Redis 宕机时，请求在 Redis 中只进行了前置的防重和数量验证，此时则没有任何影响，直接返回给客户扣减失败即可。

但如果此时 Redis 中的 lua 脚本执行到了扣减逻辑并做了实际的扣减，则会出现数据丢失的情况。因为 Redis 没有事务的保证，宕机时已经扣减的数量不会回滚。宕机导致扣减服务给客户返回扣减失败，但实际上 Redis 已经扣减了部分数据并刷新了磁盘，当此 Redis 故障处理完成再次启动后或者 failover 之后，部分库存数量已经丢失了。

为了解决此问题，可以使用数据库中的数据进行校准。常见方式是开发对账程序，通过对比 Redis 与数据库中的数据是否一致，并结合扣减服务的日志。当发现数据不一致同时日志记录扣减失败时，可以将数据库比 Redis 多的库存数据在 Redis 中进行加回。

**第二个场景是扣减 Redis 完成并成功返回给客户后，异步刷新数据库失败了的情况**

此时，Redis 中的数据库是准的，但数据库中的库存数据是多的。在结合扣减服务的日志确定是 Redis 扣减成功但异步记录数据失败后，可以将数据库比 Redis 多的库存数据在数据库中进行扣减。

### 升级纯缓存实现方案

上述的纯缓存方案在使用了 Redis 进行扣减实现后，基本上完成了扣减的高性能和高并发，满足了我们最初的需求。那整体方案上还有哪些可以优化的空间呢？

扣减服务不仅包含扣减接口还包含数量查询接口。查询接口的量级相比写接口至少是十倍以上，即使是使用了缓存进行抗量，但读写都请求了同一个 Redis，将会导致扣减请求被读影响。

其次，运营在后台进行操作增加或者修改库存时，是在修改完数据库之后在代码中异步修改刷新 Redis。因为数据库和 Redis 不支持分布式事务，为了保证在修改时它们数据的一致性，在实际开发中，需要增加很多手段保证数据一致性，成本较高。

对于上述两个问题，我们可以做两方面的改造。

第一个，可以增加一个 Redis 从结点，在扣减服务里根据请求类型路由到不同的 Redis 节点。使用主从分离的好处是，不用太多的数据同步开发，直接使用 Redis 主从同步方案，成本低开发量小。

第二个是运营后台修改数据库数量后同步至 Redis 的逻辑使用 binlog 进行处理。当商家修改了数据库中的数量之后，MySQL 等数据库的 binlog 会自动发出，在数据转换模块接受 binlog 并转换格式插入 Redis 即可。因为 binlog 消费是采用 ack 机制，如果在转换和插入 Redis 时出错，ack 不确定即可。下一次数据转换代码运行时，会继续上一次未消费的 binlog 继续执行。最终，binlog 的机制不需要太多逻辑处理即可达到最终一致性。相比采用不借助 binlog 的方式，此方案成本和复杂度均较低。

优化后的整体方案如下图所示。

<img src="./image/Cgp9HWAtBDeACk3rAAG0IGEPeS4366.png" />

### 纯缓存方案适用性分析

相比于纯数据库扣减方案，纯缓存方案也存在一定的优缺点和适用性。

纯缓存方案的主要优点是性能提升明显。使用缓存的扣减方案在保证了扣减的原子性和一致性等功能性要求之外，相比纯数据库的扣减方案至少提升十倍以上。

除了优点之外，纯缓存的方案同样存在一些缺点。Redis 及其他一些缓存实现，为了高性能，并没有实现数据库的 ACID 特性。导致在极端情况下可能会出现丢数据，进而产生少卖。另外，为了保证不出现少卖，纯缓存的方案需要做很多的对账、异常处理等的设计，系统复杂度会大幅增加。

对于纯缓存的扣减的优缺点有了一定了解后，可以发现纯缓存在抗并发流量时，效果非常显著。因此，它较适合应用于高并发、大流量的互联网场景。但在极端情况下，可能会出现一些数据的丢失。因此，它优先适合对于数据精度不是特别苛刻的场景，比如用户购买限制等。

但如果上述的异常场景都有降级方案应对，保证最终一致性。它也是可以应用在库存扣减、积分扣减等等场景。