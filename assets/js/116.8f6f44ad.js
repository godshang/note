(window.webpackJsonp=window.webpackJsonp||[]).push([[116],{581:function(t,s,a){"use strict";a.r(s);var n=a(27),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"消息队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消息队列"}},[t._v("#")]),t._v(" 消息队列")]),t._v(" "),s("p",[t._v("Redis 可以用来作为一个简单的队列，实现生产者-消费者模式。与 Kafka 和 RocketMQ 这类消息队列中间件相比，Redis 实现的队列更为简单，使用也更方便。")]),t._v(" "),s("p",[t._v("Redis 只能有一组消费者，像 Kafka 那种多消费组的模式无法支持；也没有消息的 ACK 机制，可靠性无法和专业的消息队列比拟。")]),t._v(" "),s("h2",{attrs:{id:"异步消息队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#异步消息队列"}},[t._v("#")]),t._v(" 异步消息队列")]),t._v(" "),s("p",[t._v("Redis 的 list(列表) 数据结构常用来作为异步消息队列使用，使用rpush/lpush操作入队列，使用 lpop 和 rpop 来出队列。")]),t._v(" "),s("h2",{attrs:{id:"队列空了怎么办"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#队列空了怎么办"}},[t._v("#")]),t._v(" 队列空了怎么办")]),t._v(" "),s("p",[t._v("客户端是通过队列的 pop 操作来获取消息，然后进行处理。处理完了再接着获取消息，再进行处理。如此循环往复，这便是作为队列消费者的客户端的生命周期。")]),t._v(" "),s("p",[t._v("可是如果队列空了，客户端就会陷入 pop 的死循环，不停地 pop，没有数据，接着再 pop，又没有数据。这就是浪费生命的空轮询。空轮询不但拉高了客户端的 CPU，redis 的 QPS 也会被拉高，如果这样空轮询的客户端有几十来个，Redis 的慢查询可能会显著增多。")]),t._v(" "),s("p",[t._v("通常我们使用 sleep 来解决这个问题，让线程睡一会，睡个 1s 钟就可以了。不但客户端的 CPU 能降下来，Redis 的 QPS 也降下来了。")]),t._v(" "),s("h2",{attrs:{id:"队列延迟"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#队列延迟"}},[t._v("#")]),t._v(" 队列延迟")]),t._v(" "),s("p",[t._v("用上面睡眠的办法可以解决问题。但是有个小问题，那就是睡眠会导致消息的延迟增大。如果只有 1 个消费者，那么这个延迟就是 1s。如果有多个消费者，这个延迟会有所下降，因为每个消费者的睡觉时间是岔开来的。")]),t._v(" "),s("p",[t._v("有没有什么办法能显著降低延迟呢？你当然可以很快想到：那就把睡觉的时间缩短点。这种方式当然可以，不过有没有更好的解决方案呢？当然也有，那就是 blpop/brpop。")]),t._v(" "),s("p",[t._v("这两个指令的前缀字符 b 代表的是 blocking，也就是阻塞读。")]),t._v(" "),s("p",[t._v("阻塞读在队列没有数据的时候，会立即进入休眠状态，一旦数据到来，则立刻醒过来。消息的延迟几乎为零。用 blpop/brpop 替代前面的 lpop/rpop，就完美解决了上面的问题。")]),t._v(" "),s("h2",{attrs:{id:"空闲连接自动断开"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#空闲连接自动断开"}},[t._v("#")]),t._v(" 空闲连接自动断开")]),t._v(" "),s("p",[t._v("你以为上面的方案真的很完美么？先别急着开心，其实他还有个问题需要解决。")]),t._v(" "),s("p",[t._v("什么问题？—— 空闲连接的问题。")]),t._v(" "),s("p",[t._v("如果线程一直阻塞在哪里，Redis 的客户端连接就成了闲置连接，闲置过久，服务器一般会主动断开连接，减少闲置资源占用。这个时候 blpop/brpop 会抛出异常来。")]),t._v(" "),s("p",[t._v("所以编写客户端消费者的时候要小心，注意捕获异常，还要重试。")]),t._v(" "),s("h2",{attrs:{id:"锁冲突处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#锁冲突处理"}},[t._v("#")]),t._v(" 锁冲突处理")]),t._v(" "),s("p",[t._v("客户端在处理请求时加锁没加成功怎么办？")]),t._v(" "),s("p",[t._v("一般有 3 种策略来处理加锁失败：")]),t._v(" "),s("ol",[s("li",[t._v("直接抛出异常，通知用户稍后重试；")]),t._v(" "),s("li",[t._v("sleep 一会再重试；")]),t._v(" "),s("li",[t._v("将请求转移至延时队列，过一会再试；")])]),t._v(" "),s("h3",{attrs:{id:"直接抛出特定类型的异常"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#直接抛出特定类型的异常"}},[t._v("#")]),t._v(" 直接抛出特定类型的异常")]),t._v(" "),s("p",[t._v("这种方式比较适合由用户直接发起的请求，用户看到错误对话框后，会先阅读对话框的内容，再点击重试，这样就可以起到人工延时的效果。如果考虑到用户体验，可以由前端的代码替代用户自己来进行延时重试控制。它本质上是对当前请求的放弃，由用户决定是否重新发起新的请求。")]),t._v(" "),s("h3",{attrs:{id:"sleep"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#sleep"}},[t._v("#")]),t._v(" sleep")]),t._v(" "),s("p",[t._v("sleep 会阻塞当前的消息处理线程，会导致队列的后续消息处理出现延迟。如果碰撞的比较频繁或者队列里消息比较多，sleep 可能并不合适。如果因为个别死锁的 key 导致加锁不成功，线程会彻底堵死，导致后续消息永远得不到及时处理。")]),t._v(" "),s("h3",{attrs:{id:"延时队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#延时队列"}},[t._v("#")]),t._v(" 延时队列")]),t._v(" "),s("p",[t._v("这种方式比较适合异步消息处理，将当前冲突的请求扔到另一个队列延后处理以避开冲突。")]),t._v(" "),s("h2",{attrs:{id:"延时队列的实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#延时队列的实现"}},[t._v("#")]),t._v(" 延时队列的实现")]),t._v(" "),s("p",[t._v("延时队列可以通过 Redis 的 zset(有序列表) 来实现。我们将消息序列化成一个字符串作为 zset 的 value，这个消息的到期处理时间作为 score，然后用多个线程轮询 zset 获取到期\n的任务进行处理，多个线程是为了保障可用性，万一挂了一个线程还有其它线程可以继续处理。因为有多个线程，所以需要考虑并发争抢任务，确保任务不能被多次执行。")]),t._v(" "),s("div",{staticClass:"language-python extra-class"},[s("pre",{pre:!0,attrs:{class:"language-python"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("delay")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("msg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("  msg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("id")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("str")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("uuid"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("uuid4"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 保证 value 值唯一  ")]),t._v("\n    value "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" json"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("dumps"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("msg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  \n    retry_ts "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" time"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("time"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 5 秒后重试  ")]),t._v("\n    redis"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("zadd"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"delay-queue"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" retry_ts"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  \n\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("def")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("loop")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("  \n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("while")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("True")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("  \n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 最多取 1 条  ")]),t._v("\n        values "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" redis"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("zrangebyscore"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"delay-queue"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" time"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("time"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" start"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" num"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  \n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("not")]),t._v(" values"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("\n            time"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("sleep"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 延时队列空的，休息 1s  ")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("continue")]),t._v("  \n        value "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" values"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 拿第一条，也只有一条  ")]),t._v("\n        success "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" redis"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("zrem"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"delay-queue"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 从消息队列中移除该消息  ")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" success"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 因为有多进程并发的可能，最终只会有一个进程可以抢到消息  ")]),t._v("\n            msg "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" json"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("loads"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("  \n            handle_msg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("msg"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),s("p",[t._v("Redis 的 zrem 方法是多线程多进程争抢任务的关键，它的返回值决定了当前实例有没有抢到任务，因为 loop 方法可能会被多个线程、多个进程调用，同一个任务可能会被多个进程线程抢到，通过 zrem 来决定唯一的属主。")]),t._v(" "),s("p",[t._v("同时，我们要注意一定要对 handle_msg 进行异常捕获，避免因为个别任务处理问题导致循环异常退出。")]),t._v(" "),s("h2",{attrs:{id:"进一步优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#进一步优化"}},[t._v("#")]),t._v(" 进一步优化")]),t._v(" "),s("p",[t._v("上面的算法中同一个任务可能会被多个进程取到之后再使用 zrem 进行争抢，那些没抢到的进程都是白取了一次任务，这是浪费。可以考虑使用 lua scripting 来优化一下这个逻辑，将zrangebyscore 和 zrem 一同挪到服务器端进行原子化操作，这样多个进程之间争抢任务时就不会出现这种浪费了。")])])}),[],!1,null,null,null);s.default=e.exports}}]);