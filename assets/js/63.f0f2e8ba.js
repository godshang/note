(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{480:function(e,t,a){e.exports=a.p+"assets/img/f3e4e8a7fa00392de465dee762d90df9.f3e4e8a7.png"},583:function(e,t,a){"use strict";a.r(t);var r=a(27),s=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"布隆过滤器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#布隆过滤器"}},[e._v("#")]),e._v(" 布隆过滤器")]),e._v(" "),t("p",[e._v("布隆过滤器可以理解为一个不怎么精确的 set 结构，当你使用它的 contains 方法判断某个对象是否存在时，它可能会误判。但是布隆过滤器也不是特别不精确，只要参数设置的合理，它的精确度可以控制的相对足够精确，只会有小小的误判概率。")]),e._v(" "),t("p",[e._v("当布隆过滤器说某个值存在时，这个值可能不存在；当它说不存在时，那就肯定不存在。")]),e._v(" "),t("h2",{attrs:{id:"布隆过滤器的原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#布隆过滤器的原理"}},[e._v("#")]),e._v(" 布隆过滤器的原理")]),e._v(" "),t("img",{attrs:{src:a(480)}}),e._v(" "),t("p",[e._v("每个布隆过滤器对应到 Redis 的数据结构里面就是一个大型的位数组和几个不一样的无偏 hash 函数。所谓无偏就是能够把元素的 hash 值算得比较均匀。")]),e._v(" "),t("p",[e._v("向布隆过滤器中添加 key 时，会使用多个 hash 函数对 key 进行 hash 算得一个整数索引值然后对位数组长度进行取模运算得到一个位置，每个 hash 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 1 就完成了 add 操作。")]),e._v(" "),t("p",[e._v("向布隆过滤器询问 key 是否存在时，跟 add 一样，也会把 hash 的几个位置都算出来，看看位数组中这几个位置是否都位 1，只要有一个位为 0，那么说明布隆过滤器中这个 key 不存在。如果都是 1，这并不能说明这个 key 就一定存在，只是极有可能存在，因为这些位被置为 1 可能是因为其它的 key 存在所致。如果这个位数组比较稀疏，这个概率就会很大，如果这个位数组比较拥挤，这个概率就会降低。具体的概率计算公式比较复杂，感兴趣可以阅读扩展阅读，非常烧脑，不建议读者细看。")]),e._v(" "),t("p",[e._v("使用时不要让实际元素远大于初始化大小，当实际元素开始超出初始化大小时，应该对布隆过滤器进行重建，重新分配一个 size 更大的过滤器，再将所有的历史元素批量 add 进去 (这就要求我们在其它的存储器中记录所有的历史元素)。因为 error_rate 不会因为数量超出就急剧增加，这就给我们重建过滤器提供了较为宽松的时间。")]),e._v(" "),t("h2",{attrs:{id:"reference"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reference"}},[e._v("#")]),e._v(" Reference")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/43263751",target:"_blank",rel:"noopener noreferrer"}},[e._v("详解布隆过滤器的原理，使用场景和注意事项"),t("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=s.exports}}]);