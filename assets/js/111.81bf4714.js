(window.webpackJsonp=window.webpackJsonp||[]).push([[111],{574:function(e,_,v){"use strict";v.r(_);var r=v(27),a=Object(r.a)({},(function(){var e=this,_=e._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引"}},[e._v("#")]),e._v(" 索引")]),e._v(" "),_("h2",{attrs:{id:"索引是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引是什么"}},[e._v("#")]),e._v(" 索引是什么")]),e._v(" "),_("p",[e._v("索引是提升查询效率的一种数据结构。之所以能提升查询效率， 是因为在插入的时候对数据进行了排序。缺点是影响插入或更新的性能。")]),e._v(" "),_("p",[e._v("从数据结构的角度来看， MySQL 常见索引有 B+树索引、HASH 索引、Full-Text 索引。InnoDB存储引擎只支持B+ Tree索引，MyISAM存储引擎支持B+树索引和Full-Text索引。在MySQL 8.0版本中，InnoDB支持B+树索引、全文索引、R树索引。")]),e._v(" "),_("h2",{attrs:{id:"b-树-索引的优势"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#b-树-索引的优势"}},[e._v("#")]),e._v(" B+树 索引的优势")]),e._v(" "),_("p",[e._v("如果你被问到“为什么 MySQL 会选择 B+Tree 当索引数据结构？”其实在考察你两个方面： B+Tree 的索引原理； B+Tree 索引相比于其他索引类型的优势。")]),e._v(" "),_("p",[e._v("B+Tree 相对于 B 树 索引结构的优势：")]),e._v(" "),_("ul",[_("li",[e._v("B+Tree 只在叶子节点存储数据，而 B 树 的非叶子节点也要存储数据，所以 B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。")]),e._v(" "),_("li",[e._v("B+Tree 叶子节点采用的是单链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。")])]),e._v(" "),_("p",[e._v("B+Tree 相对于二叉树索引结构的优势：")]),e._v(" "),_("ul",[_("li",[e._v("对于有 N 个叶子节点的 B+Tree，其搜索复杂度为O(logdN)，其中 d 表示节点允许的最大子节点个数为 d 个。在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据（这里的查询参考上面 B+Tree 的聚簇索引的查询过程）。")]),e._v(" "),_("li",[e._v("而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 O(logN)，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。")])]),e._v(" "),_("p",[e._v("B+Tree 相对于 Hash 表存储结构的优势：")]),e._v(" "),_("ul",[_("li",[e._v("我们知道范围查询是 MySQL 中常见的场景，但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。")])]),e._v(" "),_("p",[e._v("至此，你就知道“为什么 MySQL 会选择 B+Tree 来做索引”了。在回答时，你要着眼于 B+Tree 的优势，然后再引入索引原理的查询过程（掌握这些知识点，这个问题其实比较容易回答）。")]),e._v(" "),_("h2",{attrs:{id:"通过执行计划查看索引使用详情"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#通过执行计划查看索引使用详情"}},[e._v("#")]),e._v(" 通过执行计划查看索引使用详情")]),e._v(" "),_("p",[e._v("对于执行计划，参数有 possible_keys 字段表示可能用到的索引，key 字段表示实际用的索引，key_len 表示索引的长度，rows 表示扫描的数据行数。")]),e._v(" "),_("p",[e._v("这其中需要你重点关注 type 字段， 表示数据扫描类型，也就是描述了找到所需数据时使用的扫描方式是什么，常见扫描类型的执行效率从低到高的顺序为（考虑到查询效率问题，全表扫描和全索引扫描要尽量避免）：")]),e._v(" "),_("ul",[_("li",[e._v("ALL（全表扫描）；")]),e._v(" "),_("li",[e._v("index（全索引扫描）；")]),e._v(" "),_("li",[e._v("range（索引范围扫描）；")]),e._v(" "),_("li",[e._v("ref（非唯一索引扫描）；")]),e._v(" "),_("li",[e._v("eq_ref（唯一索引扫描）；")]),e._v(" "),_("li",[e._v("const（结果只有一条的主键或唯一索引扫描）。")])]),e._v(" "),_("p",[e._v("总的来说，执行计划是研发工程师分析索引详情必会的技能（很多大厂公司招聘 JD 上写着“SQL 语句调优” ），所以你在面试时也要知道执行计划核心参数的含义，如 type。在回答时，也要以重点参数为切入点，再扩展到其他参数，然后再说自己是怎么做 SQL 优化工作的。")]),e._v(" "),_("h2",{attrs:{id:"索引失效的常见情况"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引失效的常见情况"}},[e._v("#")]),e._v(" 索引失效的常见情况")]),e._v(" "),_("ul",[_("li",[e._v("索引列上做了计算、函数、类型转换操作，这些情况下索引失效是因为查询过程需要扫描整个索引并回表，代价高于直接全表扫描。")]),e._v(" "),_("li",[e._v("like匹配使用了前缀匹配符“%abc”。")]),e._v(" "),_("li",[e._v("字符串不加引号导致类型转换。")]),e._v(" "),_("li",[e._v("where语句中包含or时，可能会导致索引失效，需要看or左右两边的查询列是否命中相同的索引。")]),e._v(" "),_("li",[e._v("where语句中索引列使用了负向查询，可能会导致索引失效")]),e._v(" "),_("li",[e._v("在索引列上使用内置函数，一定会导致索引失效")]),e._v(" "),_("li",[e._v("对索引列进行运算，一定会导致索引失效")]),e._v(" "),_("li",[e._v("联合索引中，where中索引列违背最左匹配原则，一定会导致索引失效")]),e._v(" "),_("li",[e._v("如果MySQL查询优化器预估走索引的代价比全表扫描的代价还要大，则不走索引，直接全表扫描，如果走索引比全表扫描代价小，则使用索引。")])]),e._v(" "),_("h2",{attrs:{id:"索引优化的常见方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#索引优化的常见方法"}},[e._v("#")]),e._v(" 索引优化的常见方法")]),e._v(" "),_("h3",{attrs:{id:"前缀索引优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前缀索引优化"}},[e._v("#")]),e._v(" 前缀索引优化")]),e._v(" "),_("p",[e._v("前缀索引就是用某个字段中，字符串的前几个字符建立索引，比如我们可以在订单表上对商品名称字段的前 5 个字符建立索引。使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。")]),e._v(" "),_("p",[e._v("但是，前缀索引有一定的局限性，例如 order by 就无法使用前缀索引，无法把前缀索引用作覆盖索引。")]),e._v(" "),_("h3",{attrs:{id:"覆盖索引优化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#覆盖索引优化"}},[e._v("#")]),e._v(" 覆盖索引优化")]),e._v(" "),_("p",[e._v("覆盖索引是指 SQL 中 query 的所有字段，在索引 B+tree 的叶子节点上都能找得到的那些索引，从辅助索引中查询得到记录，而不需要通过聚簇索引查询获得。假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？")]),e._v(" "),_("p",[e._v("我们可以建立一个组合索引，即商品ID、名称、价格作为一个组合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。所以，使用覆盖索引的好处很明显，即不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。")]),e._v(" "),_("h3",{attrs:{id:"联合索引"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#联合索引"}},[e._v("#")]),e._v(" 联合索引")]),e._v(" "),_("p",[e._v("联合索引时，存在最左匹配原则，也就是按照最左优先的方式进行索引的匹配。比如联合索引 (userpin, username)，如果查询条件是 WHERE userpin=1 AND username=2，就可以匹配上联合索引；或者查询条件是 WHERE userpin=1，也能匹配上联合索引，但是如果查询条件是 WHERE username=2，就无法匹配上联合索引。")]),e._v(" "),_("p",[e._v("另外，建立联合索引时的字段顺序，对索引效率也有很大影响。越靠前的字段被用于索引过滤的概率越高，实际开发工作中建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到。")]),e._v(" "),_("p",[e._v("区分度就是某个字段 column 不同值的个数除以表的总行数，比如性别的区分度就很小，不适合建立索引或不适合排在联合索引列的靠前的位置，而 uuid 这类字段就比较适合做索引或排在联合索引列的靠前的位置。")])])}),[],!1,null,null,null);_.default=a.exports}}]);