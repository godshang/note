(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{533:function(t,a,s){"use strict";s.r(a);var n=s(27),e=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"知识点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#知识点"}},[t._v("#")]),t._v(" 知识点")]),t._v(" "),a("h2",{attrs:{id:"数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[t._v("#")]),t._v(" 数据类型")]),t._v(" "),a("h3",{attrs:{id:"java基本数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java基本数据类型"}},[t._v("#")]),t._v(" Java基本数据类型")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[a("strong",[t._v("名称")])]),t._v(" "),a("th",[a("strong",[t._v("字节")])]),t._v(" "),a("th",[a("strong",[t._v("最小值")])]),t._v(" "),a("th",[a("strong",[t._v("最大值")])]),t._v(" "),a("th",[a("strong",[t._v("描述")])])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("byte")]),t._v(" "),a("td",[t._v("1")]),t._v(" "),a("td",[t._v("-128(-2^7)")]),t._v(" "),a("td",[t._v("127(2^7-1)")]),t._v(" "),a("td",[t._v("8位有正负的二进制整数")])]),t._v(" "),a("tr",[a("td",[t._v("short")]),t._v(" "),a("td",[t._v("2")]),t._v(" "),a("td",[t._v("-2^15")]),t._v(" "),a("td",[t._v("2^15-1")]),t._v(" "),a("td",[t._v("16位有正负的二进制整数")])]),t._v(" "),a("tr",[a("td",[t._v("int")]),t._v(" "),a("td",[t._v("4")]),t._v(" "),a("td",[t._v("-2^31")]),t._v(" "),a("td",[t._v("2^31 -1")]),t._v(" "),a("td",[t._v("32位有正负的二进制整数")])]),t._v(" "),a("tr",[a("td",[t._v("long")]),t._v(" "),a("td",[t._v("8")]),t._v(" "),a("td",[t._v("-2^63")]),t._v(" "),a("td",[t._v("2^63 -1")]),t._v(" "),a("td",[t._v("64位有正负的二进制整数")])]),t._v(" "),a("tr",[a("td",[t._v("float")]),t._v(" "),a("td",[t._v("4")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td",[t._v("32位IEEE 754标准下的浮点数据")])]),t._v(" "),a("tr",[a("td",[t._v("double")]),t._v(" "),a("td",[t._v("8")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td",[t._v("64位IEEE 754标准下的浮点数据")])]),t._v(" "),a("tr",[a("td",[t._v("boolean")]),t._v(" "),a("td",[t._v("1bit")]),t._v(" "),a("td"),t._v(" "),a("td"),t._v(" "),a("td")]),t._v(" "),a("tr",[a("td",[t._v("char")]),t._v(" "),a("td",[t._v("2")]),t._v(" "),a("td",[t._v("'\\u0000' (或 0)")]),t._v(" "),a("td",[t._v("'\\uffff' (或 65，535 )")]),t._v(" "),a("td",[t._v("16 位 Unicode 标准下的字符")])])])]),t._v(" "),a("h3",{attrs:{id:"缓存池"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#缓存池"}},[t._v("#")]),t._v(" 缓存池")]),t._v(" "),a("p",[t._v("new Integer(123) 与 Integer.valueOf(123) 的区别在于：")]),t._v(" "),a("ul",[a("li",[t._v("new Integer(123) 每次都会新建一个对象")]),t._v(" "),a("li",[t._v("Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。")])]),t._v(" "),a("p",[t._v("valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("valueOf")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("IntegerCache")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("low "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("IntegerCache")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("high"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("IntegerCache")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("cache"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("IntegerCache")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("low"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("在 Java 8 中，Integer 缓存池的大小默认为 -128~127。")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" low "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("128")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" high"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),t._v(" cache"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// high value may be configured by property")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" h "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("127")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" integerCacheHighPropValue "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v("\n        sun"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("misc"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("VM")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("getSavedProperty")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"java.lang.Integer.IntegerCache.high"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("integerCacheHighPropValue "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("!=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("try")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("parseInt")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("integerCacheHighPropValue"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            i "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Math")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("max")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("127")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Maximum array size is Integer.MAX_VALUE")]),t._v("\n            h "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Math")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("min")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("MAX_VALUE")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("low"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("catch")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("NumberFormatException")]),t._v(" nfe"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// If the property cannot be parsed into an int, ignore it.")]),t._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    high "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" h"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    cache "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("high "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" low"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" j "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" low"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" k "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" k "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" cache"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" k"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n        cache"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("k"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("j"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// range [-128, 127] must be interned (JLS7 5.1.7)")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("assert")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("IntegerCache")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("high "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("127")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("编译器会在缓冲池范围内的基本类型自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),t._v(" m "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("123")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),t._v(" n "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("123")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("m "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n")])])]),a("p",[t._v("基本类型对应的缓冲池如下：")]),t._v(" "),a("ul",[a("li",[t._v("boolean values true and false")]),t._v(" "),a("li",[t._v("all byte values")]),t._v(" "),a("li",[t._v("short values between -128 and 127")]),t._v(" "),a("li",[t._v("int values between -128 and 127")]),t._v(" "),a("li",[t._v("char in the range \\u0000 to \\u007F")])]),t._v(" "),a("h2",{attrs:{id:"string"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string"}},[t._v("#")]),t._v(" String")]),t._v(" "),a("p",[t._v("String 被声明为 final，因此它不可被继承。")]),t._v(" "),a("p",[t._v("内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。")]),t._v(" "),a("h3",{attrs:{id:"不可变的好处"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不可变的好处"}},[t._v("#")]),t._v(" 不可变的好处：")]),t._v(" "),a("ol",[a("li",[t._v("可以缓存 hash 值")])]),t._v(" "),a("p",[t._v("因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("String Pool 的需要")])]),t._v(" "),a("p",[t._v("如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("安全性")])]),t._v(" "),a("p",[t._v("String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。")]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[t._v("线程安全")])]),t._v(" "),a("p",[t._v("String 不可变性天生具备线程安全，可以在多个线程中安全地使用。")]),t._v(" "),a("h3",{attrs:{id:"string-stringbuffer-and-stringbuilder"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string-stringbuffer-and-stringbuilder"}},[t._v("#")]),t._v(" String, StringBuffer and StringBuilder")]),t._v(" "),a("ol",[a("li",[t._v("可变性")])]),t._v(" "),a("ul",[a("li",[t._v("String 不可变")]),t._v(" "),a("li",[t._v("StringBuffer 和 StringBuilder 可变")])]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("线程安全")])]),t._v(" "),a("ul",[a("li",[t._v("String 不可变，因此是线程安全的")]),t._v(" "),a("li",[t._v("StringBuilder 不是线程安全的")]),t._v(" "),a("li",[t._v("StringBuffer 是线程安全的，内部使用 synchronized 进行同步")])]),t._v(" "),a("h3",{attrs:{id:"string-intern"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string-intern"}},[t._v("#")]),t._v(" String.intern()")]),t._v(" "),a("p",[t._v("使用 String.intern() 可以保证相同内容的字符串变量引用同一的内存对象。")]),t._v(" "),a("p",[t._v("下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同对象，而 s3 是通过 s1.intern() 方法取得一个对象引用。intern() 首先把 s1 引用的对象放到 String Pool(字符串常量池)中，然后返回这个对象引用。因此 s3 和 s1 引用的是同一个字符串常量池的对象。")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" s1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"aaa"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" s2 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"aaa"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s1 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" s2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("           "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// false")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v(" s3 "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" s1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("intern")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("System")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("out"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("println")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("s1"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("intern")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" s3"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// true")]),t._v("\n")])])]),a("p",[t._v('如果是采用 "bbb" 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Pool 中。')]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('String s4 = "bbb";\nString s5 = "bbb";\nSystem.out.println(s4 == s5);  // true\n')])])]),a("p",[t._v("HotSpot中字符串常量池保存哪里？永久代？方法区还是堆区？")]),t._v(" "),a("ol",[a("li",[t._v("运行时常量池（Runtime Constant Pool）是虚拟机规范中是方法区的一部分，在加载类和结构到虚拟机后，就会创建对应的运行时常量池；而字符串常量池是这个过程中常量字符串的存放位置。所以从这个角度，字符串常量池属于虚拟机规范中的方法区，它是一个逻辑上的概念；而堆区，永久代以及元空间是实际的存放位置。")]),t._v(" "),a("li",[t._v("不同的虚拟机对虚拟机的规范（比如方法区）是不一样的，只有 HotSpot 才有永久代的概念。")]),t._v(" "),a("li",[t._v("HotSpot也是发展的，由于一些问题的存在，HotSpot考虑逐渐去永久代，对于不同版本的JDK，实际的存储位置是有差异的，具体看如下表格：")])]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("JDK版本")]),t._v(" "),a("th",[t._v("是否有永久代，字符串常量池放在哪里？")]),t._v(" "),a("th",[t._v("方法区逻辑上规范，由哪些实际的部分实现的？")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("jdk1.6及之前")]),t._v(" "),a("td",[t._v("有永久代，运行时常量池（包括字符串常量池），静态变量存放在永久代上")]),t._v(" "),a("td",[t._v("这个时期方法区在HotSpot中是由永久代来实现的，以至于这个时期说方法区就是指永久代")])]),t._v(" "),a("tr",[a("td",[t._v("jdk1.7")]),t._v(" "),a("td",[t._v("有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中；")]),t._v(" "),a("td",[t._v("这个时期方法区在HotSpot中由永久代（类型信息、字段、方法、常量）和堆（字符串常量池、静态变量）共同实现")])]),t._v(" "),a("tr",[a("td",[t._v("jdk1.8及之后")]),t._v(" "),a("td",[t._v("取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中")]),t._v(" "),a("td",[t._v("这个时期方法区在HotSpot中由本地内存的元空间（类型信息、字段、方法、常量）和堆（字符串常量池、静态变量）共同实现")])])])]),t._v(" "),a("h2",{attrs:{id:"访问权限"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#访问权限"}},[t._v("#")]),t._v(" 访问权限")]),t._v(" "),a("p",[t._v("Java 中有三个访问权限修饰符: private、protected 以及 public，如果不加访问修饰符，表示包级可见。")]),t._v(" "),a("p",[t._v("可以对类或类中的成员(字段以及方法)加上访问修饰符。")]),t._v(" "),a("ul",[a("li",[t._v("类可见表示其它类可以用这个类创建实例对象。")]),t._v(" "),a("li",[t._v("成员可见表示其它类可以用这个类的实例对象访问到该成员。")])]),t._v(" "),a("p",[t._v("protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。")]),t._v(" "),a("p",[t._v("设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。")]),t._v(" "),a("p",[t._v("如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。")]),t._v(" "),a("h2",{attrs:{id:"抽象类和接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#抽象类和接口"}},[t._v("#")]),t._v(" 抽象类和接口")]),t._v(" "),a("ol",[a("li",[t._v("抽象类")])]),t._v(" "),a("p",[t._v("抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。")]),t._v(" "),a("p",[t._v("抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("接口")])]),t._v(" "),a("p",[t._v("接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。")]),t._v(" "),a("p",[t._v("从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。")]),t._v(" "),a("p",[t._v("接口的成员(字段 + 方法)默认都是 public 的，并且不允许定义为 private 或者 protected。")]),t._v(" "),a("p",[t._v("接口的字段默认都是 static 和 final 的。")]),t._v(" "),a("ol",{attrs:{start:"3"}},[a("li",[t._v("比较")])]),t._v(" "),a("ul",[a("li",[t._v("从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。")]),t._v(" "),a("li",[t._v("从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。")]),t._v(" "),a("li",[t._v("接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。")]),t._v(" "),a("li",[t._v("接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。")])]),t._v(" "),a("ol",{attrs:{start:"4"}},[a("li",[t._v("使用选择")])]),t._v(" "),a("p",[t._v("使用接口:")]),t._v(" "),a("ul",[a("li",[t._v("需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；")]),t._v(" "),a("li",[t._v("需要使用多重继承。")])]),t._v(" "),a("p",[t._v("使用抽象类:")]),t._v(" "),a("ul",[a("li",[t._v("需要在几个相关的类中共享代码。")]),t._v(" "),a("li",[t._v("需要能控制继承来的成员的访问权限，而不是都为 public。")]),t._v(" "),a("li",[t._v("需要继承非静态和非常量字段。")])]),t._v(" "),a("p",[t._v("在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。")]),t._v(" "),a("h2",{attrs:{id:"static初始化顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#static初始化顺序"}},[t._v("#")]),t._v(" static初始化顺序")]),t._v(" "),a("p",[t._v("静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。")]),t._v(" "),a("p",[t._v("存在继承的情况下，初始化顺序为：")]),t._v(" "),a("ul",[a("li",[t._v("父类(静态变量、静态语句块)")]),t._v(" "),a("li",[t._v("子类(静态变量、静态语句块)")]),t._v(" "),a("li",[t._v("父类(实例变量、普通语句块)")]),t._v(" "),a("li",[t._v("父类(构造函数)")]),t._v(" "),a("li",[t._v("子类(实例变量、普通语句块)")]),t._v(" "),a("li",[t._v("子类(构造函数)")])]),t._v(" "),a("h2",{attrs:{id:"equals方法和hashcode方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#equals方法和hashcode方法"}},[t._v("#")]),t._v(" equals方法和hashCode方法")]),t._v(" "),a("p",[t._v("equals是比较值是否相等。一般比较对象是否相等都用equals，equals方法主要是用来判断从表面上看或者从内容上看，2个对象是不是相等。比较两个枚举类型的值的时候不要调用equals，直接使用“==”就可以。")]),t._v(" "),a("p",[t._v("hashCode实际上就是一个对象的MD5。对比起来比equals快得多。他是一个整数值，但是没有规律的。java中默认的散列码就是对象的存储地址。")]),t._v(" "),a("p",[t._v("对象相等则hashCode一定相等；hashCode相等对象未必相等。")]),t._v(" "),a("p",[t._v("注意：重载equals的时候，一定要(must)（正确）重载hashCode 。使得equals成立的时候，hashCode相等。使两个逻辑相等。我们在定义hashCode方法时，要乘以一些奇数（最好是素数），这是是为了在理论上增大哈希值得离散程度。这是数学上证明的问题。你需要知道的是，hashcode就是为了哈希索引用的，哈希值分布的越均匀，map数据结构的查询效率越高。")]),t._v(" "),a("h2",{attrs:{id:"object类有哪些方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object类有哪些方法"}},[t._v("#")]),t._v(" Object类有哪些方法？")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("Object()")]),t._v(" "),a("th",[t._v("默认构造方法")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("clone()")]),t._v(" "),a("td",[t._v("创建并返回此对象的一个副本。")])]),t._v(" "),a("tr",[a("td",[t._v("equals(Object obj)")]),t._v(" "),a("td",[t._v("指示某个其他对象是否与此对象“相等”。")])]),t._v(" "),a("tr",[a("td",[t._v("finalize()")]),t._v(" "),a("td",[t._v("当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。")])]),t._v(" "),a("tr",[a("td",[t._v("getClass()")]),t._v(" "),a("td",[t._v("返回一个对象的运行时类。")])]),t._v(" "),a("tr",[a("td",[t._v("hashCode()")]),t._v(" "),a("td",[t._v("返回该对象的哈希码值。")])]),t._v(" "),a("tr",[a("td",[t._v("notify()")]),t._v(" "),a("td",[t._v("唤醒在此对象监视器上等待的单个线程。")])]),t._v(" "),a("tr",[a("td",[t._v("notifyAll()")]),t._v(" "),a("td",[t._v("唤醒在此对象监视器上等待的所有线程。")])]),t._v(" "),a("tr",[a("td",[t._v("toString()")]),t._v(" "),a("td",[t._v("返回该对象的字符串表示。")])]),t._v(" "),a("tr",[a("td",[t._v("wait()")]),t._v(" "),a("td",[t._v("导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。")])]),t._v(" "),a("tr",[a("td",[t._v("wait(long timeout)")]),t._v(" "),a("td",[t._v("导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。")])]),t._v(" "),a("tr",[a("td",[t._v("wait(long timeout， int nanos)")]),t._v(" "),a("td",[t._v("导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。")])])])]),t._v(" "),a("h2",{attrs:{id:"java的四种引用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java的四种引用"}},[t._v("#")]),t._v(" Java的四种引用")]),t._v(" "),a("p",[a("strong",[t._v("强引用(StrongReference)")])]),t._v(" "),a("p",[t._v("强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。")]),t._v(" "),a("p",[a("strong",[t._v("软引用(SoftReference)")])]),t._v(" "),a("p",[t._v("如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。\n软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。")]),t._v(" "),a("p",[a("strong",[t._v("弱引用(WeakReference)")])]),t._v(" "),a("p",[t._v("弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。")]),t._v(" "),a("p",[t._v("弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。")]),t._v(" "),a("p",[a("strong",[t._v("虚引用(PhantomReference)")])]),t._v(" "),a("p",[t._v('"虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。')]),t._v(" "),a("p",[a("strong",[t._v("总结")])]),t._v(" "),a("p",[t._v("WeakReference与SoftReference都可以用来保存对象的实例引用，这两个类与垃圾回收有关。")]),t._v(" "),a("p",[t._v("WeakReference是弱引用，其中保存的对象实例可以被GC回收掉。这个类通常用于在某处保存对象引用，而又不干扰该对象被GC回收，通常用于Debug、内存监视工具等程序中。因为这类程序一般要求即要观察到对象，又不能影响该对象正常的GC过程。")]),t._v(" "),a("p",[t._v("最近在JDK的Proxy类的实现代码中也发现了Weakrefrence的应用，Proxy会把动态生成的Class实例暂存于一个由Weakrefrence构成的Map中作为Cache。SoftReference是强引用，它保存的对象实例，除非JVM即将OutOfMemory，否则不会被GC回收。")]),t._v(" "),a("p",[t._v("这个特性使得它特别适合设计对象Cache。对于Cache，我们希望被缓存的对象最好始终常驻内存，但是如果JVM内存吃紧，为了不发生OutOfMemoryError导致系统崩溃，必要的时候也允许JVM回收Cache的内存，待后续合适的时机再把数据重新Load到Cache中。这样可以系统设计得更具弹性。")]),t._v(" "),a("h2",{attrs:{id:"string-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string-2"}},[t._v("#")]),t._v(" String")]),t._v(" "),a("p",[t._v("String 被声明为final，因此它不可继承。")]),t._v(" "),a("p",[t._v("内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("implements")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[a("span",{pre:!0,attrs:{class:"token namespace"}},[t._v("java"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("io"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")])]),t._v("Serializable")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Comparable")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CharSequence")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/** The value is used for character storage. */")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("private")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("final")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),t._v(" value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("不可变的好处：")]),t._v(" "),a("ul",[a("li",[t._v("可以缓存 hash 值：因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。")]),t._v(" "),a("li",[t._v("String Pool 的需要：如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。")]),t._v(" "),a("li",[t._v("安全性：String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。")]),t._v(" "),a("li",[t._v("线程安全：String 不可变性天生具备线程安全，可以在多个线程中安全地使用。")])]),t._v(" "),a("h2",{attrs:{id:"string-stringbuffer-和-stringbuilder-的区别是什么-string-为什么是不可变的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string-stringbuffer-和-stringbuilder-的区别是什么-string-为什么是不可变的"}},[t._v("#")]),t._v(" String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?")]),t._v(" "),a("p",[a("strong",[t._v("可变性")])]),t._v(" "),a("p",[t._v("String 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]，所以 String 对象是不可变的。")]),t._v(" "),a("p",[t._v("在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 private final byte[] value;")]),t._v(" "),a("p",[t._v("而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。")]),t._v(" "),a("p",[t._v("StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的。 AbstractStringBuilder 实现上类似 ArrayList 。")]),t._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("abstract")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("class")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AbstractStringBuilder")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("implements")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Appendable")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CharSequence")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n     * The value is used for character storage.\n     */")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("/**\n     * The count is the number of characters used.\n     */")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" count"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AbstractStringBuilder")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" capacity"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        value "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("char")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("capacity"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[a("strong",[t._v("线程安全性")])]),t._v(" "),a("p",[t._v("String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。")]),t._v(" "),a("p",[a("strong",[t._v("性能")])]),t._v(" "),a("p",[t._v("每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。")]),t._v(" "),a("p",[a("strong",[t._v("对于三者使用的总结")])]),t._v(" "),a("ol",[a("li",[t._v("操作少量的数据: 适用 String")]),t._v(" "),a("li",[t._v("单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder")]),t._v(" "),a("li",[t._v("多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer")])]),t._v(" "),a("h2",{attrs:{id:"在-java-中定义一个不做事且没有参数的构造方法的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#在-java-中定义一个不做事且没有参数的构造方法的作用"}},[t._v("#")]),t._v(" 在 Java 中定义一个不做事且没有参数的构造方法的作用")]),t._v(" "),a("p",[t._v("Java 程序在执行子类的构造方法之前，如果没有用 super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super()来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。")]),t._v(" "),a("h2",{attrs:{id:"object-object-new-object-在内存中占了多少字节"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-object-new-object-在内存中占了多少字节"}},[t._v("#")]),t._v(" Object object = new Object() 在内存中占了多少字节？")]),t._v(" "),a("p",[t._v("普通对象在内存中的存储布局：")]),t._v(" "),a("ul",[a("li",[t._v("对象头 markword")]),t._v(" "),a("li",[t._v("类型指针 class pointer")]),t._v(" "),a("li",[t._v("实例数据 instance data")]),t._v(" "),a("li",[t._v("对齐 padding")])]),t._v(" "),a("p",[t._v("数组对象在内存中的存储布局：")]),t._v(" "),a("ul",[a("li",[t._v("对象头 markword")]),t._v(" "),a("li",[t._v("类型指针 class pointer")]),t._v(" "),a("li",[t._v("数组长度 length 4字节")]),t._v(" "),a("li",[t._v("实例数据 instance data")]),t._v(" "),a("li",[t._v("对齐 padding")])]),t._v(" "),a("p",[t._v("markword长8个字节；对于64位虚拟机，指针长度为64位8个字节，如果开启了压缩指针（-XX:UseCompressedClassPointers，默认开启），那么就是4个字节；再加上对齐4字节，共16字节。")]),t._v(" "),a("p",[t._v("如果算上对象应用的指针的话，就是20字节。")])])}),[],!1,null,null,null);a.default=e.exports}}]);