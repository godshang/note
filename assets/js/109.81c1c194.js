(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{570:function(o,r,a){"use strict";a.r(r);var t=a(27),_=Object(t.a)({},(function(){var o=this,r=o._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[r("h1",{attrs:{id:"事务acid特性的实现原理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#事务acid特性的实现原理"}},[o._v("#")]),o._v(" 事务ACID特性的实现原理")]),o._v(" "),r("p",[o._v("事务是数据库操作的执行单元，一个事务中可能包含一个或多个SQL语句，这些语句要么都执行，要么都不执行。在MySQL中，事务是由存储引擎实现的，MySQL支持事务的存储引擎包括InnoDB、NDB Cluster等，其他存储引擎不支持事务，如MyIsam、Memory等。")]),o._v(" "),r("p",[o._v("事务具有ACID四个属性，分别是：")]),o._v(" "),r("ul",[r("li",[o._v("原子性（Atomicity）")]),o._v(" "),r("li",[o._v("一致性（Consistency）")]),o._v(" "),r("li",[o._v("隔离性（Isolation）")]),o._v(" "),r("li",[o._v("持久性（Durability）")])]),o._v(" "),r("p",[o._v("按照严格的标准，只有同时满足ACID特性才是事务；但是在各大数据库厂商的实现中，真正满足ACID的事务少之又少。例如MySQL的NDB Cluster事务不满足持久性和隔离性；InnoDB默认事务隔离级别是可重复读，不满足隔离性；Oracle默认的事务隔离级别为READ COMMITTED，不满足隔离性……因此与其说ACID是事务必须满足的条件，不如说它们是衡量事务的四个维度。")]),o._v(" "),r("h2",{attrs:{id:"原子性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#原子性"}},[o._v("#")]),o._v(" 原子性")]),o._v(" "),r("h3",{attrs:{id:"定义"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[o._v("#")]),o._v(" 定义")]),o._v(" "),r("p",[o._v("原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做；如果事务中一个sql语句执行失败，则已执行的语句也必须回滚，数据库退回到事务前的状态。")]),o._v(" "),r("h3",{attrs:{id:"实现原理-undo-log"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实现原理-undo-log"}},[o._v("#")]),o._v(" 实现原理：undo log")]),o._v(" "),r("p",[o._v("在说明原子性原理之前，首先介绍一下MySQL的事务日志。MySQL的日志有很多种，如二进制日志、错误日志、查询日志、慢查询日志等，此外InnoDB存储引擎还提供了两种事务日志：redo log(重做日志)和undo log(回滚日志)。其中redo log用于保证事务持久性；undo log则是事务原子性和隔离性实现的基础。")]),o._v(" "),r("p",[o._v("下面说回undo log。实现原子性的关键，是当事务回滚时能够撤销所有已经成功执行的sql语句。InnoDB实现回滚，靠的是undo log：当事务对数据库进行修改时，InnoDB会生成对应的undo log；如果事务执行失败或调用了rollback，导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。")]),o._v(" "),r("p",[o._v("undo log属于逻辑日志，它记录的是sql执行相关的信息。当发生回滚时，InnoDB会根据undo log的内容做与之前相反的工作：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。")]),o._v(" "),r("p",[o._v("以update操作为例：当事务执行update时，其生成的undo log中会包含被修改行的主键(以便知道修改了哪些行)、修改了哪些列、这些列在修改前后的值等信息，回滚时便可以使用这些信息将数据还原到update之前的状态。")]),o._v(" "),r("h2",{attrs:{id:"持久性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#持久性"}},[o._v("#")]),o._v(" 持久性")]),o._v(" "),r("h3",{attrs:{id:"定义-2"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#定义-2"}},[o._v("#")]),o._v(" 定义")]),o._v(" "),r("p",[o._v("持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。")]),o._v(" "),r("h3",{attrs:{id:"实现原理-redo-log"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实现原理-redo-log"}},[o._v("#")]),o._v(" 实现原理：redo log")]),o._v(" "),r("p",[o._v("redo log和undo log都属于InnoDB的事务日志。下面先聊一下redo log存在的背景。")]),o._v(" "),r("p",[o._v("InnoDB作为MySQL的存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了缓存(Buffer Pool)，Buffer Pool中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会定期刷新到磁盘中（这一过程称为刷脏）。")]),o._v(" "),r("p",[o._v("Buffer Pool的使用大大提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。")]),o._v(" "),r("p",[o._v("于是，redo log被引入来解决这个问题：当数据修改时，除了修改Buffer Pool中的数据，还会在redo log记录这次操作；当事务提交时，会调用fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是WAL（Write-ahead logging，预写式日志），所有修改先写入日志，再更新到Buffer Pool，保证了数据不会因MySQL宕机而丢失，从而满足了持久性要求。")]),o._v(" "),r("p",[o._v("既然redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快呢？主要有以下两方面的原因：")]),o._v(" "),r("p",[o._v("（1）刷脏是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO。")]),o._v(" "),r("p",[o._v("（2）刷脏是以数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入；而redo log中只包含真正需要写入的部分，无效IO大大减少。")]),o._v(" "),r("h3",{attrs:{id:"redo-log与binlog"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#redo-log与binlog"}},[o._v("#")]),o._v(" redo log与binlog")]),o._v(" "),r("p",[o._v("我们知道，在MySQL中还存在binlog(二进制日志)也可以记录写操作并用于数据的恢复，但二者是有着根本的不同的：")]),o._v(" "),r("p",[o._v("（1）作用不同：redo log是用于crash recovery的，保证MySQL宕机也不会影响持久性；binlog是用于point-in-time recovery的，保证服务器可以基于时间点恢复数据，此外binlog还用于主从复制。")]),o._v(" "),r("p",[o._v("（2）层次不同：redo log是InnoDB存储引擎实现的，而binlog是MySQL的服务器层(可以参考文章前面对MySQL逻辑架构的介绍)实现的，同时支持InnoDB和其他存储引擎。")]),o._v(" "),r("p",[o._v("（3）内容不同：redo log是物理日志，内容基于磁盘的Page；binlog的内容是二进制的，根据binlog_format参数的不同，可能基于sql语句、基于数据本身或者二者的混合。")]),o._v(" "),r("p",[o._v("（4）写入时机不同：binlog在事务提交时写入；redo log的写入时机相对多元：")]),o._v(" "),r("ul",[r("li",[o._v("前面曾提到：当事务提交时会调用fsync对redo log进行刷盘；这是默认情况下的策略，修改innodb_flush_log_at_trx_commit参数可以改变该策略，但事务的持久性将无法保证。")]),o._v(" "),r("li",[o._v("除了事务提交时，还有其他刷盘时机：如master thread每秒刷盘一次redo log等，这样的好处是不一定要等到commit时刷盘，commit速度大大加快。")])]),o._v(" "),r("h2",{attrs:{id:"隔离性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#隔离性"}},[o._v("#")]),o._v(" 隔离性")]),o._v(" "),r("h3",{attrs:{id:"定义-3"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#定义-3"}},[o._v("#")]),o._v(" 定义")]),o._v(" "),r("p",[o._v("与原子性、持久性侧重于研究事务本身不同，隔离性研究的是不同事务之间的相互影响。隔离性是指，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。严格的隔离性，对应了事务隔离级别中的Serializable (可串行化)，但实际应用中出于性能方面的考虑很少会使用可串行化。")]),o._v(" "),r("p",[o._v("隔离性追求的是并发情形下事务之间互不干扰。简单起见，我们主要考虑最简单的读操作和写操作(加锁读等特殊读操作会特殊说明)，那么隔离性的探讨，主要可以分为两个方面：")]),o._v(" "),r("ul",[r("li",[o._v("(一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性")]),o._v(" "),r("li",[o._v("(一个事务)写操作对(另一个事务)读操作的影响：MVCC保证隔离性")])]),o._v(" "),r("h3",{attrs:{id:"锁机制"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#锁机制"}},[o._v("#")]),o._v(" 锁机制")]),o._v(" "),r("p",[o._v("首先来看两个事务的写操作之间的相互影响。隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB通过锁机制来保证这一点。")]),o._v(" "),r("p",[o._v("锁机制的基本原理可以概括为：事务在修改数据之前，需要先获得相应的锁；获得锁之后，事务便可以修改数据；该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。")]),o._v(" "),r("p",[r("strong",[o._v("行锁与表锁")])]),o._v(" "),r("p",[o._v("按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。表锁在操作数据时会锁定整张表，并发性能较差；行锁则只锁定需要操作的数据，并发性能好。但是由于加锁本身需要消耗资源(获得锁、检查锁、释放锁等都需要消耗资源)，因此在锁定数据较多情况下使用表锁可以节省大量资源。MySQL中不同的存储引擎支持的锁是不一样的，例如MyIsam只支持表锁，而InnoDB同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。")]),o._v(" "),r("h2",{attrs:{id:"一致性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一致性"}},[o._v("#")]),o._v(" 一致性")]),o._v(" "),r("h3",{attrs:{id:"定义-4"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#定义-4"}},[o._v("#")]),o._v(" 定义")]),o._v(" "),r("p",[o._v("一致性是指事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。数据库的完整性约束包括但不限于：实体完整性（如行的主键存在且唯一）、列完整性（如字段的类型、大小、长度要符合要求）、外键约束、用户自定义完整性（如转账前后，两个账户余额的和应该不变）。")]),o._v(" "),r("h3",{attrs:{id:"实现"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实现"}},[o._v("#")]),o._v(" 实现")]),o._v(" "),r("p",[o._v("可以说，一致性是事务追求的最终目标：前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性。此外，除了数据库层面的保障，一致性的实现也需要应用层面进行保障。")]),o._v(" "),r("p",[o._v("实现一致性的措施包括：")]),o._v(" "),r("ul",[r("li",[o._v("保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证")]),o._v(" "),r("li",[o._v("数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等")]),o._v(" "),r("li",[o._v("应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致")])])])}),[],!1,null,null,null);r.default=_.exports}}]);