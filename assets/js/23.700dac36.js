(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{431:function(e,o,l){e.exports=l.p+"assets/img/20191114145726.2779e3e5.png"},432:function(e,o,l){e.exports=l.p+"assets/img/20191114152023.561e230d.png"},433:function(e,o,l){e.exports=l.p+"assets/img/20191114162100.4079402b.png"},434:function(e,o,l){e.exports=l.p+"assets/img/20191114173404.b3e5e98e.png"},435:function(e,o,l){e.exports=l.p+"assets/img/20191114173621.29d36f29.png"},436:function(e,o,l){e.exports=l.p+"assets/img/20191114174804.830d06da.png"},569:function(e,o,l){"use strict";l.r(o);var s=l(27),v=Object(s.a)({},(function(){var e=this,o=e._self._c;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"io-模型"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#io-模型"}},[e._v("#")]),e._v(" IO 模型")]),e._v(" "),o("p",[e._v("Linux有5种IO模型：")]),e._v(" "),o("ul",[o("li",[e._v("同步阻塞式IO")]),e._v(" "),o("li",[e._v("同步非阻塞式IO")]),e._v(" "),o("li",[e._v("IO多路复用")]),e._v(" "),o("li",[e._v("信号驱动式IO")]),e._v(" "),o("li",[e._v("异步非阻塞IO")])]),e._v(" "),o("p",[e._v("网络IO的本质是socket的读取，当一个读操作发生时，通常包括两个不同的阶段：")]),e._v(" "),o("ol",[o("li",[e._v("等待数据准备好")]),e._v(" "),o("li",[e._v("从内核向进程复制数据")])]),e._v(" "),o("p",[e._v("第2步是不同IO模型中差别较大的地方。")]),e._v(" "),o("h2",{attrs:{id:"同步阻塞式io"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#同步阻塞式io"}},[e._v("#")]),e._v(" 同步阻塞式IO")]),e._v(" "),o("p",[e._v("阻塞式IO模型是最简单和最常见的。在Linux中，默认情况下所有的socket都是blocking。")]),e._v(" "),o("p",[e._v("在这个IO模型中，用户空间的应用程序执行一个系统调用（recvform），这会导致应用程序阻塞，什么也不干，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据，在等待数据到处理数据的两个阶段，整个进程都被阻塞。不能处理别的网络IO。调用应用程序处于一种不再消费 CPU 而只是简单等待响应的状态，因此从处理的角度来看，这是非常有效的。在调用recv()/recvfrom()函数时，发生在内核中等待数据和复制数据的过程，大致如下图：")]),e._v(" "),o("img",{attrs:{src:l(431)}}),e._v(" "),o("p",[e._v("当用户进程调用了recv()/recvfrom()这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。第二个阶段：当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。")]),e._v(" "),o("p",[e._v("blocking IO的特点就是在IO执行的两个阶段都被block了。")]),e._v(" "),o("p",[e._v("优点：")]),e._v(" "),o("ol",[o("li",[e._v("能够及时返回数据，无延迟")]),e._v(" "),o("li",[e._v("对内核开发者来说这是省事了")])]),e._v(" "),o("p",[e._v("缺点：")]),e._v(" "),o("ol",[o("li",[e._v("对用户来说处于等待就要付出性能的代价")])]),e._v(" "),o("h2",{attrs:{id:"同步非阻塞式io"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#同步非阻塞式io"}},[e._v("#")]),e._v(" 同步非阻塞式IO")]),e._v(" "),o("p",[e._v("同步非阻塞就是 “每隔一会儿瞄一眼进度条” 的轮询（polling）方式。在这种模型中，设备是以非阻塞的形式打开的。这意味着 IO 操作不会立即完成，read 操作可能会返回一个错误代码，说明这个命令不能立即满足（EAGAIN 或 EWOULDBLOCK）。")]),e._v(" "),o("p",[e._v("在网络IO时候，非阻塞IO也会进行recvform系统调用，检查数据是否准备好，与阻塞IO不一样，\"非阻塞将大的整片时间的阻塞分成N多的小的阻塞, 所以进程不断地有机会 '被' CPU光顾\"。")]),e._v(" "),o("p",[e._v("也就是说非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。进程在返回之后，可以干点别的事情，然后再发起recvform系统调用。重复上面的过程，循环往复的进行recvform系统调用。这个过程通常被称之为轮询。轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。")]),e._v(" "),o("p",[e._v("在linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程如图所示：")]),e._v(" "),o("img",{attrs:{src:l(432)}}),e._v(" "),o("p",[e._v("当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。")]),e._v(" "),o("p",[e._v("所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。")]),e._v(" "),o("p",[e._v("同步非阻塞方式相比同步阻塞方式：")]),e._v(" "),o("ul",[o("li",[e._v("优点：能够在等待任务完成的时间里干其他活了（包括提交其他任务，也就是 “后台” 可以有多个任务在同时执行）。")]),e._v(" "),o("li",[e._v("缺点：任务完成的响应延迟增大了，因为每过一段时间才去轮询一次read操作，而任务可能在两次轮询之间的任意时间完成。这会导致整体数据吞吐量的降低。")])]),e._v(" "),o("h2",{attrs:{id:"io多路复用"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#io多路复用"}},[e._v("#")]),e._v(" IO多路复用")]),e._v(" "),o("p",[e._v("由于同步非阻塞方式需要不断主动轮询，轮询占据了很大一部分过程，轮询会消耗大量的CPU时间，而 “后台” 可能有多个任务在同时进行，人们就想到了循环查询多个任务的完成状态，只要有任何一个任务完成，就去处理它。如果轮询不是进程的用户态，而是有人帮忙就好了。那么这就是所谓的 “IO 多路复用”。UNIX/Linux 下的 select、poll、epoll 就是干这个的（epoll 比 poll、select 效率高，做的事情是一样的）。")]),e._v(" "),o("p",[e._v('IO多路复用有两个特别的系统调用select、poll、epoll函数。select调用是内核级别的，select轮询相对非阻塞的轮询的区别在于---前者可以等待多个socket，能实现同时对多个IO端口进行监听，当其中任何一个socket的数据准好了，就能返回进行可读，然后进程再进行recvform系统调用，将数据由内核拷贝到用户进程，当然这个过程是阻塞的。select或poll调用之后，会阻塞进程，与blocking IO阻塞不同在于，此时的select不是等到socket数据全部到达再处理, 而是有了一部分数据就会调用用户进程来处理。如何知道有一部分数据到达了呢？监视的事情交给了内核，内核负责数据到达的处理。也可以理解为"非阻塞"吧。')]),e._v(" "),o("p",[e._v("I/O复用模型会用到select、poll、epoll函数，这几个函数也会使进程阻塞，但是和阻塞I/O所不同的的，这两个函数可以同时阻塞多个I/O操作。而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时（注意不是全部数据可读或可写），才真正调用I/O操作函数。")]),e._v(" "),o("p",[e._v("对于多路复用，也就是轮询多个socket。多路复用既然可以处理多个IO，也就带来了新的问题，多个IO之间的顺序变得不确定了，当然也可以针对不同的编号。具体流程，如下图所示：")]),e._v(" "),o("img",{attrs:{src:l(433)}}),e._v(" "),o("p",[e._v("IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。")]),e._v(" "),o("p",[e._v("当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。")]),e._v(" "),o("p",[e._v("多路复用的特点是通过一种机制一个进程能同时等待IO文件描述符，内核监视这些文件描述符（套接字描述符），其中的任意一个进入读就绪状态，select， poll，epoll函数就可以返回。对于监视的方式，又可以分为 select， poll， epoll三种方式。")]),e._v(" "),o("p",[e._v("上面的图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。")]),e._v(" "),o("p",[e._v("所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。（select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）")]),e._v(" "),o("p",[e._v("在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。所以IO多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。")]),e._v(" "),o("p",[e._v("在I/O编程过程中，当需要同时处理多个客户端接入请求时，可以利用多线程或者I/O多路复用技术进行处理。I/O多路复用技术通过把多个I/O的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程/多进程模型比，I/O多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程，也不需要维护这些进程和线程的运行，降底了系统的维护工作量，节省了系统资源，I/O多路复用的主要应用场景如下：")]),e._v(" "),o("ul",[o("li",[e._v("服务器需要同时处理多个处于监听状态或者多个连接状态的套接字。")]),e._v(" "),o("li",[e._v("服务器需要同时处理多种网络协议的套接字。")])]),e._v(" "),o("p",[e._v("了解了前面三种IO模式，在用户进程进行系统调用的时候，他们在等待数据到来的时候，处理的方式不一样，直接等待，轮询，select或poll轮询，两个阶段过程：")]),e._v(" "),o("ul",[o("li",[e._v("第一个阶段有的阻塞，有的不阻塞，有的可以阻塞又可以不阻塞。")]),e._v(" "),o("li",[e._v("第二个阶段都是阻塞的。")])]),e._v(" "),o("p",[e._v("从整个IO过程来看，他们都是顺序执行的，因此可以归为同步模型(synchronous)。都是进程主动等待且向内核检查状态。【此句很重要！！！】")]),e._v(" "),o("p",[e._v("高并发的程序一般使用同步非阻塞方式而非多线程 + 同步阻塞方式。要理解这一点，首先要扯到并发和并行的区别。比如去某部门办事需要依次去几个窗口，办事大厅里的人数就是并发数，而窗口个数就是并行度。也就是说并发数是指同时进行的任务数（如同时服务的 HTTP 请求），而并行数是可以同时工作的物理资源数量（如 CPU 核数）。通过合理调度任务的不同阶段，并发数可以远远大于并行度，这就是区区几个 CPU 可以支持上万个用户并发请求的奥秘。在这种高并发的情况下，为每个任务（用户请求）创建一个进程或线程的开销非常大。而同步非阻塞方式可以把多个 IO 请求丢到后台去，这就可以在一个进程里服务大量的并发 IO 请求。")]),e._v(" "),o("p",[e._v("注意：IO多路复用是同步阻塞模型还是异步阻塞模型，在此给大家分析下：")]),e._v(" "),o("p",[e._v("此处仍然不太清楚的，强烈建议大家在细究《聊聊同步、异步、阻塞与非阻塞》中讲同步与异步的根本性区别，同步是需要主动等待消息通知，而异步则是被动接收消息通知，通过回调、通知、状态等方式来被动获取消息。IO多路复用在阻塞到select阶段时，用户进程是主动等待并调用select函数获取数据就绪状态消息，并且其进程状态为阻塞。所以，把IO多路复用归为同步阻塞模式。")]),e._v(" "),o("h2",{attrs:{id:"信号驱动式io"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#信号驱动式io"}},[e._v("#")]),e._v(" 信号驱动式IO")]),e._v(" "),o("p",[e._v("信号驱动式I/O：首先我们允许Socket进行信号驱动IO,并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。过程如下图所示：")]),e._v(" "),o("img",{attrs:{src:l(434)}}),e._v(" "),o("h2",{attrs:{id:"异步非阻塞io"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#异步非阻塞io"}},[e._v("#")]),e._v(" 异步非阻塞IO")]),e._v(" "),o("p",[e._v("相对于同步IO，异步IO不是顺序执行。用户进程进行aio_read系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。等到socket数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。IO两个阶段，进程都是非阻塞的。")]),e._v(" "),o("p",[e._v("Linux提供了AIO库函数实现异步，但是用的很少。目前有很多开源的异步IO库，例如libevent、libev、libuv。异步过程如下图所示：")]),e._v(" "),o("img",{attrs:{src:l(435)}}),e._v(" "),o("p",[e._v("用户进程发起aio_read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal或执行一个基于线程的回调函数来完成这次 IO 处理过程，告诉它read操作完成了。")]),e._v(" "),o("p",[e._v("在 Linux 中，通知的方式是 “信号”：")]),e._v(" "),o("p",[e._v("如果这个进程正在用户态忙着做别的事（例如在计算两个矩阵的乘积），那就强行打断之，调用事先注册的信号处理函数，这个函数可以决定何时以及如何处理这个异步任务。由于信号处理函数是突然闯进来的，因此跟中断处理程序一样，有很多事情是不能做的，因此保险起见，一般是把事件 “登记” 一下放进队列，然后返回该进程原来在做的事。")]),e._v(" "),o("p",[e._v("如果这个进程正在内核态忙着做别的事，例如以同步阻塞方式读写磁盘，那就只好把这个通知挂起来了，等到内核态的事情忙完了，快要回到用户态的时候，再触发信号通知。")]),e._v(" "),o("p",[e._v("如果这个进程现在被挂起了，例如无事可做 sleep 了，那就把这个进程唤醒，下次有 CPU 空闲的时候，就会调度到这个进程，触发信号通知。")]),e._v(" "),o("p",[e._v("异步 API 说来轻巧，做来难，这主要是对 API 的实现者而言的。Linux 的异步 IO（AIO）支持是 2.6.22 才引入的，还有很多系统调用不支持异步 IO。Linux 的异步 IO 最初是为数据库设计的，因此通过异步 IO 的读写操作不会被缓存或缓冲，这就无法利用操作系统的缓存与缓冲机制。")]),e._v(" "),o("p",[e._v("很多人把 Linux 的 O_NONBLOCK 认为是异步方式，但事实上这是前面讲的同步非阻塞方式。需要指出的是，虽然 Linux 上的 IO API 略显粗糙，但每种编程框架都有封装好的异步 IO 实现。操作系统少做事，把更多的自由留给用户，正是 UNIX 的设计哲学，也是 Linux 上编程框架百花齐放的一个原因。")]),e._v(" "),o("p",[e._v("从前面 IO 模型的分类中，我们可以看出 AIO 的动机：")]),e._v(" "),o("p",[e._v("同步阻塞模型需要在 IO 操作开始时阻塞应用程序。这意味着不可能同时重叠进行处理和 IO 操作。")]),e._v(" "),o("p",[e._v("同步非阻塞模型允许处理和 IO 操作重叠进行，但是这需要应用程序根据重现的规则来检查 IO 操作的状态。")]),e._v(" "),o("p",[e._v("这样就剩下异步非阻塞 IO 了，它允许处理和 IO 操作重叠进行，包括 IO 操作完成的通知。")]),e._v(" "),o("p",[e._v("IO多路复用除了需要阻塞之外，select 函数所提供的功能（异步阻塞 IO）与 AIO 类似。不过，它是对通知事件进行阻塞，而不是对 IO 调用进行阻塞。")]),e._v(" "),o("h2",{attrs:{id:"五种io模型总结"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#五种io模型总结"}},[e._v("#")]),e._v(" 五种IO模型总结")]),e._v(" "),o("h3",{attrs:{id:"blocking和non-blocking区别"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#blocking和non-blocking区别"}},[e._v("#")]),e._v(" blocking和non-blocking区别")]),e._v(" "),o("p",[e._v("调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。")]),e._v(" "),o("h3",{attrs:{id:"synchronous-io和asynchronous-io区别"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#synchronous-io和asynchronous-io区别"}},[e._v("#")]),e._v(" synchronous IO和asynchronous IO区别")]),e._v(" "),o("p",[e._v("在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：")]),e._v(" "),o("blockquote",[o("p",[e._v("A synchronous I/O operation causes the requesting process to be blocked until that I/O operation completes;\nAn asynchronous I/O operation does not cause the requesting process to be blocked;")])]),e._v(" "),o("p",[e._v("两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。")]),e._v(" "),o("p",[e._v("有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。")]),e._v(" "),o("p",[e._v("而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。")]),e._v(" "),o("p",[e._v("各个IO Model的比较如图所示：")]),e._v(" "),o("img",{attrs:{src:l(436)}}),e._v(" "),o("p",[e._v("通过上面的图片，可以发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。")]),e._v(" "),o("blockquote",[o("p",[e._v("作者：猿码道")]),e._v(" "),o("p",[e._v("链接：https://www.jianshu.com/p/486b0965c296")]),e._v(" "),o("p",[e._v("来源：简书")]),e._v(" "),o("p",[e._v("著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。")])]),e._v(" "),o("h2",{attrs:{id:"reference"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#reference"}},[e._v("#")]),e._v(" Reference")]),e._v(" "),o("p",[o("a",{attrs:{href:"https://segmentfault.com/a/1190000003063859#articleHeader13",target:"_blank",rel:"noopener noreferrer"}},[e._v("Linux IO模式及 select、poll、epoll详解"),o("OutboundLink")],1)])])}),[],!1,null,null,null);o.default=v.exports}}]);