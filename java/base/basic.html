<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>知识点 | 开发者笔记</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/note/assets/css/0.styles.fa566ad0.css" as="style"><link rel="preload" href="/note/assets/js/app.fe0ed53e.js" as="script"><link rel="preload" href="/note/assets/js/2.7b239f4c.js" as="script"><link rel="preload" href="/note/assets/js/1.51e4995c.js" as="script"><link rel="preload" href="/note/assets/js/95.5bd3b80e.js" as="script"><link rel="prefetch" href="/note/assets/js/10.555b32ff.js"><link rel="prefetch" href="/note/assets/js/100.923d2cb5.js"><link rel="prefetch" href="/note/assets/js/101.1b10aa6b.js"><link rel="prefetch" href="/note/assets/js/102.519481ff.js"><link rel="prefetch" href="/note/assets/js/103.93f3de8d.js"><link rel="prefetch" href="/note/assets/js/104.5f17bec9.js"><link rel="prefetch" href="/note/assets/js/105.22c71f14.js"><link rel="prefetch" href="/note/assets/js/106.7aca8b70.js"><link rel="prefetch" href="/note/assets/js/107.a1b34675.js"><link rel="prefetch" href="/note/assets/js/108.3dc6e794.js"><link rel="prefetch" href="/note/assets/js/109.97ce641d.js"><link rel="prefetch" href="/note/assets/js/11.fd20f755.js"><link rel="prefetch" href="/note/assets/js/110.ed78ce1a.js"><link rel="prefetch" href="/note/assets/js/111.81bf4714.js"><link rel="prefetch" href="/note/assets/js/112.916871fd.js"><link rel="prefetch" href="/note/assets/js/113.3e03ceee.js"><link rel="prefetch" href="/note/assets/js/114.a044d982.js"><link rel="prefetch" href="/note/assets/js/115.3804ad48.js"><link rel="prefetch" href="/note/assets/js/116.8f6f44ad.js"><link rel="prefetch" href="/note/assets/js/117.e215e63e.js"><link rel="prefetch" href="/note/assets/js/118.dfeb9e88.js"><link rel="prefetch" href="/note/assets/js/119.466009e4.js"><link rel="prefetch" href="/note/assets/js/12.3ad661be.js"><link rel="prefetch" href="/note/assets/js/120.77bd5754.js"><link rel="prefetch" href="/note/assets/js/121.04ff5c2a.js"><link rel="prefetch" href="/note/assets/js/13.0bb3a7d0.js"><link rel="prefetch" href="/note/assets/js/14.f9046e47.js"><link rel="prefetch" href="/note/assets/js/15.3af5a383.js"><link rel="prefetch" href="/note/assets/js/16.c8d9f254.js"><link rel="prefetch" href="/note/assets/js/17.71204e89.js"><link rel="prefetch" href="/note/assets/js/18.831fa1a4.js"><link rel="prefetch" href="/note/assets/js/19.a6dff0f2.js"><link rel="prefetch" href="/note/assets/js/20.611906c5.js"><link rel="prefetch" href="/note/assets/js/21.8da184a7.js"><link rel="prefetch" href="/note/assets/js/22.c52856f3.js"><link rel="prefetch" href="/note/assets/js/23.700dac36.js"><link rel="prefetch" href="/note/assets/js/24.69ce0e0c.js"><link rel="prefetch" href="/note/assets/js/25.0730c414.js"><link rel="prefetch" href="/note/assets/js/26.0dc2f351.js"><link rel="prefetch" href="/note/assets/js/27.b67f9ce5.js"><link rel="prefetch" href="/note/assets/js/28.1b0ec007.js"><link rel="prefetch" href="/note/assets/js/29.fd8012dc.js"><link rel="prefetch" href="/note/assets/js/3.922513d5.js"><link rel="prefetch" href="/note/assets/js/30.eb83510f.js"><link rel="prefetch" href="/note/assets/js/31.2eff891a.js"><link rel="prefetch" href="/note/assets/js/32.1ca7680c.js"><link rel="prefetch" href="/note/assets/js/33.e23bb18b.js"><link rel="prefetch" href="/note/assets/js/34.e1b481dc.js"><link rel="prefetch" href="/note/assets/js/35.f46213e9.js"><link rel="prefetch" href="/note/assets/js/36.a5e42658.js"><link rel="prefetch" href="/note/assets/js/37.0f540e46.js"><link rel="prefetch" href="/note/assets/js/38.b372cea4.js"><link rel="prefetch" href="/note/assets/js/39.95b7b6ef.js"><link rel="prefetch" href="/note/assets/js/4.7f32a226.js"><link rel="prefetch" href="/note/assets/js/40.aacc67a1.js"><link rel="prefetch" href="/note/assets/js/41.baa508be.js"><link rel="prefetch" href="/note/assets/js/42.adae8cbf.js"><link rel="prefetch" href="/note/assets/js/43.895ef36a.js"><link rel="prefetch" href="/note/assets/js/44.bbb4481a.js"><link rel="prefetch" href="/note/assets/js/45.cbf322f4.js"><link rel="prefetch" href="/note/assets/js/46.68e5a9a5.js"><link rel="prefetch" href="/note/assets/js/47.3fddf95f.js"><link rel="prefetch" href="/note/assets/js/48.92c8b712.js"><link rel="prefetch" href="/note/assets/js/49.4c802eef.js"><link rel="prefetch" href="/note/assets/js/5.27e38e77.js"><link rel="prefetch" href="/note/assets/js/50.36092570.js"><link rel="prefetch" href="/note/assets/js/51.1113abd3.js"><link rel="prefetch" href="/note/assets/js/52.b9a2d2d1.js"><link rel="prefetch" href="/note/assets/js/53.7dc6c9ae.js"><link rel="prefetch" href="/note/assets/js/54.e1fa1251.js"><link rel="prefetch" href="/note/assets/js/55.3b47207f.js"><link rel="prefetch" href="/note/assets/js/56.e2fa0521.js"><link rel="prefetch" href="/note/assets/js/57.efe7b9d7.js"><link rel="prefetch" href="/note/assets/js/58.91a3fbe0.js"><link rel="prefetch" href="/note/assets/js/59.759256fb.js"><link rel="prefetch" href="/note/assets/js/6.eeaf7e02.js"><link rel="prefetch" href="/note/assets/js/60.63a865bc.js"><link rel="prefetch" href="/note/assets/js/61.6ea99453.js"><link rel="prefetch" href="/note/assets/js/62.92a1deae.js"><link rel="prefetch" href="/note/assets/js/63.f0f2e8ba.js"><link rel="prefetch" href="/note/assets/js/64.66ca54af.js"><link rel="prefetch" href="/note/assets/js/65.d7a5fccb.js"><link rel="prefetch" href="/note/assets/js/66.6fd1421d.js"><link rel="prefetch" href="/note/assets/js/67.ba2be8c2.js"><link rel="prefetch" href="/note/assets/js/68.73dd8a54.js"><link rel="prefetch" href="/note/assets/js/69.01ef0cca.js"><link rel="prefetch" href="/note/assets/js/7.97a5d920.js"><link rel="prefetch" href="/note/assets/js/70.c0e7f26a.js"><link rel="prefetch" href="/note/assets/js/71.6e8cf6b2.js"><link rel="prefetch" href="/note/assets/js/72.f93545c3.js"><link rel="prefetch" href="/note/assets/js/73.65ede5b3.js"><link rel="prefetch" href="/note/assets/js/74.221a3475.js"><link rel="prefetch" href="/note/assets/js/75.4f15972e.js"><link rel="prefetch" href="/note/assets/js/76.db77aaf5.js"><link rel="prefetch" href="/note/assets/js/77.57d30a26.js"><link rel="prefetch" href="/note/assets/js/78.67ade579.js"><link rel="prefetch" href="/note/assets/js/79.d209365a.js"><link rel="prefetch" href="/note/assets/js/80.3676f009.js"><link rel="prefetch" href="/note/assets/js/81.de92044c.js"><link rel="prefetch" href="/note/assets/js/82.807d0fc1.js"><link rel="prefetch" href="/note/assets/js/83.41ad2d0d.js"><link rel="prefetch" href="/note/assets/js/84.09cc5bde.js"><link rel="prefetch" href="/note/assets/js/85.5452bba4.js"><link rel="prefetch" href="/note/assets/js/86.59edb859.js"><link rel="prefetch" href="/note/assets/js/87.382dd4a3.js"><link rel="prefetch" href="/note/assets/js/88.a715c97d.js"><link rel="prefetch" href="/note/assets/js/89.c8360788.js"><link rel="prefetch" href="/note/assets/js/90.130359da.js"><link rel="prefetch" href="/note/assets/js/91.e3275599.js"><link rel="prefetch" href="/note/assets/js/92.393dd45a.js"><link rel="prefetch" href="/note/assets/js/93.33847c52.js"><link rel="prefetch" href="/note/assets/js/94.d8033e92.js"><link rel="prefetch" href="/note/assets/js/96.50504acf.js"><link rel="prefetch" href="/note/assets/js/97.636b17d3.js"><link rel="prefetch" href="/note/assets/js/98.1801094c.js"><link rel="prefetch" href="/note/assets/js/99.88e5b949.js"><link rel="prefetch" href="/note/assets/js/vendors~docsearch.69e677f0.js">
    <link rel="stylesheet" href="/note/assets/css/0.styles.fa566ad0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/note/" class="home-link router-link-active"><!----> <span class="site-name">开发者笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/note/" class="nav-link">
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/java/base/basic.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Java基础
</a></li><li class="dropdown-item"><!----> <a href="/note/java/collection/ArrayList.html" class="nav-link">
  Java集合框架
</a></li><li class="dropdown-item"><!----> <a href="/note/java/concurrent/Theory.html" class="nav-link">
  Java并发编程
</a></li><li class="dropdown-item"><!----> <a href="/note/java/jvm/memory.html" class="nav-link">
  JVM相关
</a></li><li class="dropdown-item"><!----> <a href="/note/java/nio/io.html" class="nav-link">
  Java NIO相关
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据存储" class="dropdown-title"><span class="title">数据存储</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据存储" class="mobile-dropdown-title"><span class="title">数据存储</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/storage/database/mysql.html" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/note/storage/redis/redis-question.html" class="nav-link">
  Redis
</a></li><li class="dropdown-item"><!----> <a href="/note/storage/mq/kafka-intro.html" class="nav-link">
  消息队列
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="框架" class="dropdown-title"><span class="title">框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="框架" class="mobile-dropdown-title"><span class="title">框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/framework/spring-framework/spring-framework-intro.html" class="nav-link">
  Spring框架
</a></li><li class="dropdown-item"><!----> <a href="/note/framework/netty/netty-business-logic.html" class="nav-link">
  Netty
</a></li><li class="dropdown-item"><!----> <a href="/note/framework/apollo/setup-debug-enviroment.html" class="nav-link">
  Apollo源码分析
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="架构" class="dropdown-title"><span class="title">架构</span> <span class="arrow down"></span></button> <button type="button" aria-label="架构" class="mobile-dropdown-title"><span class="title">架构</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/arch/system-design/01-scale-from-zero.html" class="nav-link">
  系统设计
</a></li><li class="dropdown-item"><!----> <a href="/note/arch/case-study/rate-limiter.html" class="nav-link">
  案例
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/note/" class="nav-link">
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/java/base/basic.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  Java基础
</a></li><li class="dropdown-item"><!----> <a href="/note/java/collection/ArrayList.html" class="nav-link">
  Java集合框架
</a></li><li class="dropdown-item"><!----> <a href="/note/java/concurrent/Theory.html" class="nav-link">
  Java并发编程
</a></li><li class="dropdown-item"><!----> <a href="/note/java/jvm/memory.html" class="nav-link">
  JVM相关
</a></li><li class="dropdown-item"><!----> <a href="/note/java/nio/io.html" class="nav-link">
  Java NIO相关
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据存储" class="dropdown-title"><span class="title">数据存储</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据存储" class="mobile-dropdown-title"><span class="title">数据存储</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/storage/database/mysql.html" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/note/storage/redis/redis-question.html" class="nav-link">
  Redis
</a></li><li class="dropdown-item"><!----> <a href="/note/storage/mq/kafka-intro.html" class="nav-link">
  消息队列
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="框架" class="dropdown-title"><span class="title">框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="框架" class="mobile-dropdown-title"><span class="title">框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/framework/spring-framework/spring-framework-intro.html" class="nav-link">
  Spring框架
</a></li><li class="dropdown-item"><!----> <a href="/note/framework/netty/netty-business-logic.html" class="nav-link">
  Netty
</a></li><li class="dropdown-item"><!----> <a href="/note/framework/apollo/setup-debug-enviroment.html" class="nav-link">
  Apollo源码分析
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="架构" class="dropdown-title"><span class="title">架构</span> <span class="arrow down"></span></button> <button type="button" aria-label="架构" class="mobile-dropdown-title"><span class="title">架构</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/arch/system-design/01-scale-from-zero.html" class="nav-link">
  系统设计
</a></li><li class="dropdown-item"><!----> <a href="/note/arch/case-study/rate-limiter.html" class="nav-link">
  案例
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Java基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note/java/base/basic.html" aria-current="page" class="active sidebar-link">Java基础-知识点</a></li><li><a href="/note/java/base/oop.html" class="sidebar-link">Java基础-面向对象</a></li><li><a href="/note/java/base/proxy.html" class="sidebar-link">Java基础-代理</a></li><li><a href="/note/java/base/spi.html" class="sidebar-link">Java基础-SPI机制</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="知识点"><a href="#知识点" class="header-anchor">#</a> 知识点</h1> <h2 id="数据类型"><a href="#数据类型" class="header-anchor">#</a> 数据类型</h2> <h3 id="java基本数据类型"><a href="#java基本数据类型" class="header-anchor">#</a> Java基本数据类型</h3> <table><thead><tr><th><strong>名称</strong></th> <th><strong>字节</strong></th> <th><strong>最小值</strong></th> <th><strong>最大值</strong></th> <th><strong>描述</strong></th></tr></thead> <tbody><tr><td>byte</td> <td>1</td> <td>-128(-2^7)</td> <td>127(2^7-1)</td> <td>8位有正负的二进制整数</td></tr> <tr><td>short</td> <td>2</td> <td>-2^15</td> <td>2^15-1</td> <td>16位有正负的二进制整数</td></tr> <tr><td>int</td> <td>4</td> <td>-2^31</td> <td>2^31 -1</td> <td>32位有正负的二进制整数</td></tr> <tr><td>long</td> <td>8</td> <td>-2^63</td> <td>2^63 -1</td> <td>64位有正负的二进制整数</td></tr> <tr><td>float</td> <td>4</td> <td></td> <td></td> <td>32位IEEE 754标准下的浮点数据</td></tr> <tr><td>double</td> <td>8</td> <td></td> <td></td> <td>64位IEEE 754标准下的浮点数据</td></tr> <tr><td>boolean</td> <td>1bit</td> <td></td> <td></td> <td></td></tr> <tr><td>char</td> <td>2</td> <td>'\u0000' (或 0)</td> <td>'\uffff' (或 65，535 )</td> <td>16 位 Unicode 标准下的字符</td></tr></tbody></table> <h3 id="缓存池"><a href="#缓存池" class="header-anchor">#</a> 缓存池</h3> <p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p> <ul><li>new Integer(123) 每次都会新建一个对象</li> <li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li></ul> <p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Integer</span> <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>high<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">128</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> high<span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Integer</span> cache<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token punctuation">{</span>
    <span class="token comment">// high value may be configured by property</span>
    <span class="token keyword">int</span> h <span class="token operator">=</span> <span class="token number">127</span><span class="token punctuation">;</span>
    <span class="token class-name">String</span> integerCacheHighPropValue <span class="token operator">=</span>
        sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span><span class="token constant">VM</span><span class="token punctuation">.</span><span class="token function">getSavedProperty</span><span class="token punctuation">(</span><span class="token string">&quot;java.lang.Integer.IntegerCache.high&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>integerCacheHighPropValue <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span>integerCacheHighPropValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
            i <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">127</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// Maximum array size is Integer.MAX_VALUE</span>
            h <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token operator">-</span>low<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span> <span class="token class-name">NumberFormatException</span> nfe<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// If the property cannot be parsed into an int, ignore it.</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    high <span class="token operator">=</span> h<span class="token punctuation">;</span>

    cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">[</span><span class="token punctuation">(</span>high <span class="token operator">-</span> low<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> j <span class="token operator">=</span> low<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> cache<span class="token punctuation">.</span>length<span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span>
        cache<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span>
    <span class="token keyword">assert</span> <span class="token class-name">IntegerCache</span><span class="token punctuation">.</span>high <span class="token operator">&gt;=</span> <span class="token number">127</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>编译器会在缓冲池范围内的基本类型自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">Integer</span> m <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token class-name">Integer</span> n <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>m <span class="token operator">==</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
</code></pre></div><p>基本类型对应的缓冲池如下：</p> <ul><li>boolean values true and false</li> <li>all byte values</li> <li>short values between -128 and 127</li> <li>int values between -128 and 127</li> <li>char in the range \u0000 to \u007F</li></ul> <h2 id="string"><a href="#string" class="header-anchor">#</a> String</h2> <p>String 被声明为 final，因此它不可被继承。</p> <p>内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p> <h3 id="不可变的好处"><a href="#不可变的好处" class="header-anchor">#</a> 不可变的好处：</h3> <ol><li>可以缓存 hash 值</li></ol> <p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p> <ol start="2"><li>String Pool 的需要</li></ol> <p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p> <ol start="3"><li>安全性</li></ol> <p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p> <ol start="4"><li>线程安全</li></ol> <p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p> <h3 id="string-stringbuffer-and-stringbuilder"><a href="#string-stringbuffer-and-stringbuilder" class="header-anchor">#</a> String, StringBuffer and StringBuilder</h3> <ol><li>可变性</li></ol> <ul><li>String 不可变</li> <li>StringBuffer 和 StringBuilder 可变</li></ul> <ol start="2"><li>线程安全</li></ol> <ul><li>String 不可变，因此是线程安全的</li> <li>StringBuilder 不是线程安全的</li> <li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li></ul> <h3 id="string-intern"><a href="#string-intern" class="header-anchor">#</a> String.intern()</h3> <p>使用 String.intern() 可以保证相同内容的字符串变量引用同一的内存对象。</p> <p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同对象，而 s3 是通过 s1.intern() 方法取得一个对象引用。intern() 首先把 s1 引用的对象放到 String Pool(字符串常量池)中，然后返回这个对象引用。因此 s3 和 s1 引用的是同一个字符串常量池的对象。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;aaa&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">&quot;aaa&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// false</span>
<span class="token class-name">String</span> s3 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> s3<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span>
</code></pre></div><p>如果是采用 &quot;bbb&quot; 这种使用双引号的形式创建字符串实例，会自动地将新建的对象放入 String Pool 中。</p> <div class="language- extra-class"><pre class="language-text"><code>String s4 = &quot;bbb&quot;;
String s5 = &quot;bbb&quot;;
System.out.println(s4 == s5);  // true
</code></pre></div><p>HotSpot中字符串常量池保存哪里？永久代？方法区还是堆区？</p> <ol><li>运行时常量池（Runtime Constant Pool）是虚拟机规范中是方法区的一部分，在加载类和结构到虚拟机后，就会创建对应的运行时常量池；而字符串常量池是这个过程中常量字符串的存放位置。所以从这个角度，字符串常量池属于虚拟机规范中的方法区，它是一个逻辑上的概念；而堆区，永久代以及元空间是实际的存放位置。</li> <li>不同的虚拟机对虚拟机的规范（比如方法区）是不一样的，只有 HotSpot 才有永久代的概念。</li> <li>HotSpot也是发展的，由于一些问题的存在，HotSpot考虑逐渐去永久代，对于不同版本的JDK，实际的存储位置是有差异的，具体看如下表格：</li></ol> <table><thead><tr><th>JDK版本</th> <th>是否有永久代，字符串常量池放在哪里？</th> <th>方法区逻辑上规范，由哪些实际的部分实现的？</th></tr></thead> <tbody><tr><td>jdk1.6及之前</td> <td>有永久代，运行时常量池（包括字符串常量池），静态变量存放在永久代上</td> <td>这个时期方法区在HotSpot中是由永久代来实现的，以至于这个时期说方法区就是指永久代</td></tr> <tr><td>jdk1.7</td> <td>有永久代，但已经逐步“去永久代”，字符串常量池、静态变量移除，保存在堆中；</td> <td>这个时期方法区在HotSpot中由永久代（类型信息、字段、方法、常量）和堆（字符串常量池、静态变量）共同实现</td></tr> <tr><td>jdk1.8及之后</td> <td>取消永久代，类型信息、字段、方法、常量保存在本地内存的元空间，但字符串常量池、静态变量仍在堆中</td> <td>这个时期方法区在HotSpot中由本地内存的元空间（类型信息、字段、方法、常量）和堆（字符串常量池、静态变量）共同实现</td></tr></tbody></table> <h2 id="访问权限"><a href="#访问权限" class="header-anchor">#</a> 访问权限</h2> <p>Java 中有三个访问权限修饰符: private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p> <p>可以对类或类中的成员(字段以及方法)加上访问修饰符。</p> <ul><li>类可见表示其它类可以用这个类创建实例对象。</li> <li>成员可见表示其它类可以用这个类的实例对象访问到该成员。</li></ul> <p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p> <p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。</p> <p>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。</p> <h2 id="抽象类和接口"><a href="#抽象类和接口" class="header-anchor">#</a> 抽象类和接口</h2> <ol><li>抽象类</li></ol> <p>抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。</p> <p>抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。</p> <ol start="2"><li>接口</li></ol> <p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p> <p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。</p> <p>接口的成员(字段 + 方法)默认都是 public 的，并且不允许定义为 private 或者 protected。</p> <p>接口的字段默认都是 static 和 final 的。</p> <ol start="3"><li>比较</li></ol> <ul><li>从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li> <li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li> <li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li> <li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li></ul> <ol start="4"><li>使用选择</li></ol> <p>使用接口:</p> <ul><li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；</li> <li>需要使用多重继承。</li></ul> <p>使用抽象类:</p> <ul><li>需要在几个相关的类中共享代码。</li> <li>需要能控制继承来的成员的访问权限，而不是都为 public。</li> <li>需要继承非静态和非常量字段。</li></ul> <p>在很多情况下，接口优先于抽象类，因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p> <h2 id="static初始化顺序"><a href="#static初始化顺序" class="header-anchor">#</a> static初始化顺序</h2> <p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p> <p>存在继承的情况下，初始化顺序为：</p> <ul><li>父类(静态变量、静态语句块)</li> <li>子类(静态变量、静态语句块)</li> <li>父类(实例变量、普通语句块)</li> <li>父类(构造函数)</li> <li>子类(实例变量、普通语句块)</li> <li>子类(构造函数)</li></ul> <h2 id="equals方法和hashcode方法"><a href="#equals方法和hashcode方法" class="header-anchor">#</a> equals方法和hashCode方法</h2> <p>equals是比较值是否相等。一般比较对象是否相等都用equals，equals方法主要是用来判断从表面上看或者从内容上看，2个对象是不是相等。比较两个枚举类型的值的时候不要调用equals，直接使用“==”就可以。</p> <p>hashCode实际上就是一个对象的MD5。对比起来比equals快得多。他是一个整数值，但是没有规律的。java中默认的散列码就是对象的存储地址。</p> <p>对象相等则hashCode一定相等；hashCode相等对象未必相等。</p> <p>注意：重载equals的时候，一定要(must)（正确）重载hashCode 。使得equals成立的时候，hashCode相等。使两个逻辑相等。我们在定义hashCode方法时，要乘以一些奇数（最好是素数），这是是为了在理论上增大哈希值得离散程度。这是数学上证明的问题。你需要知道的是，hashcode就是为了哈希索引用的，哈希值分布的越均匀，map数据结构的查询效率越高。</p> <h2 id="object类有哪些方法"><a href="#object类有哪些方法" class="header-anchor">#</a> Object类有哪些方法？</h2> <table><thead><tr><th>Object()</th> <th>默认构造方法</th></tr></thead> <tbody><tr><td>clone()</td> <td>创建并返回此对象的一个副本。</td></tr> <tr><td>equals(Object obj)</td> <td>指示某个其他对象是否与此对象“相等”。</td></tr> <tr><td>finalize()</td> <td>当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。</td></tr> <tr><td>getClass()</td> <td>返回一个对象的运行时类。</td></tr> <tr><td>hashCode()</td> <td>返回该对象的哈希码值。</td></tr> <tr><td>notify()</td> <td>唤醒在此对象监视器上等待的单个线程。</td></tr> <tr><td>notifyAll()</td> <td>唤醒在此对象监视器上等待的所有线程。</td></tr> <tr><td>toString()</td> <td>返回该对象的字符串表示。</td></tr> <tr><td>wait()</td> <td>导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法。</td></tr> <tr><td>wait(long timeout)</td> <td>导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者超过指定的时间量。</td></tr> <tr><td>wait(long timeout， int nanos)</td> <td>导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量。</td></tr></tbody></table> <h2 id="java的四种引用"><a href="#java的四种引用" class="header-anchor">#</a> Java的四种引用</h2> <p><strong>强引用(StrongReference)</strong></p> <p>强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。</p> <p><strong>软引用(SoftReference)</strong></p> <p>如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p> <p><strong>弱引用(WeakReference)</strong></p> <p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。</p> <p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p> <p><strong>虚引用(PhantomReference)</strong></p> <p>&quot;虚引用&quot;顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。</p> <p><strong>总结</strong></p> <p>WeakReference与SoftReference都可以用来保存对象的实例引用，这两个类与垃圾回收有关。</p> <p>WeakReference是弱引用，其中保存的对象实例可以被GC回收掉。这个类通常用于在某处保存对象引用，而又不干扰该对象被GC回收，通常用于Debug、内存监视工具等程序中。因为这类程序一般要求即要观察到对象，又不能影响该对象正常的GC过程。</p> <p>最近在JDK的Proxy类的实现代码中也发现了Weakrefrence的应用，Proxy会把动态生成的Class实例暂存于一个由Weakrefrence构成的Map中作为Cache。SoftReference是强引用，它保存的对象实例，除非JVM即将OutOfMemory，否则不会被GC回收。</p> <p>这个特性使得它特别适合设计对象Cache。对于Cache，我们希望被缓存的对象最好始终常驻内存，但是如果JVM内存吃紧，为了不发生OutOfMemoryError导致系统崩溃，必要的时候也允许JVM回收Cache的内存，待后续合适的时机再把数据重新Load到Cache中。这样可以系统设计得更具弹性。</p> <h2 id="string-2"><a href="#string-2" class="header-anchor">#</a> String</h2> <p>String 被声明为final，因此它不可继承。</p> <p>内部使用 char 数组存储数据，该数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">String</span>
    <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">,</span> <span class="token class-name">Comparable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> <span class="token punctuation">{</span>
    <span class="token comment">/** The value is used for character storage. */</span>
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> value<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>不可变的好处：</p> <ul><li>可以缓存 hash 值：因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</li> <li>String Pool 的需要：如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</li> <li>安全性：String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</li> <li>线程安全：String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</li></ul> <h2 id="string-stringbuffer-和-stringbuilder-的区别是什么-string-为什么是不可变的"><a href="#string-stringbuffer-和-stringbuilder-的区别是什么-string-为什么是不可变的" class="header-anchor">#</a> String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</h2> <p><strong>可变性</strong></p> <p>String 类中使用 final 关键字修饰字符数组来保存字符串，private final char value[]，所以 String 对象是不可变的。</p> <p>在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 private final byte[] value;</p> <p>而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串char[]value 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p> <p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的。 AbstractStringBuilder 实现上类似 ArrayList 。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractStringBuilder</span> <span class="token keyword">implements</span> <span class="token class-name">Appendable</span><span class="token punctuation">,</span> <span class="token class-name">CharSequence</span> <span class="token punctuation">{</span>
    <span class="token comment">/**
     * The value is used for character storage.
     */</span>
    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> value<span class="token punctuation">;</span>

    <span class="token comment">/**
     * The count is the number of characters used.
     */</span>
    <span class="token keyword">int</span> count<span class="token punctuation">;</span>

    <span class="token class-name">AbstractStringBuilder</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        value <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">char</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p><strong>线程安全性</strong></p> <p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p> <p><strong>性能</strong></p> <p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p> <p><strong>对于三者使用的总结</strong></p> <ol><li>操作少量的数据: 适用 String</li> <li>单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder</li> <li>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</li></ol> <h2 id="在-java-中定义一个不做事且没有参数的构造方法的作用"><a href="#在-java-中定义一个不做事且没有参数的构造方法的作用" class="header-anchor">#</a> 在 Java 中定义一个不做事且没有参数的构造方法的作用</h2> <p>Java 程序在执行子类的构造方法之前，如果没有用 super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super()来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p> <h2 id="object-object-new-object-在内存中占了多少字节"><a href="#object-object-new-object-在内存中占了多少字节" class="header-anchor">#</a> Object object = new Object() 在内存中占了多少字节？</h2> <p>普通对象在内存中的存储布局：</p> <ul><li>对象头 markword</li> <li>类型指针 class pointer</li> <li>实例数据 instance data</li> <li>对齐 padding</li></ul> <p>数组对象在内存中的存储布局：</p> <ul><li>对象头 markword</li> <li>类型指针 class pointer</li> <li>数组长度 length 4字节</li> <li>实例数据 instance data</li> <li>对齐 padding</li></ul> <p>markword长8个字节；对于64位虚拟机，指针长度为64位8个字节，如果开启了压缩指针（-XX:UseCompressedClassPointers，默认开启），那么就是4个字节；再加上对齐4字节，共16字节。</p> <p>如果算上对象应用的指针的话，就是20字节。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/note/java/base/oop.html">
        Java基础-面向对象
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/note/assets/js/app.fe0ed53e.js" defer></script><script src="/note/assets/js/2.7b239f4c.js" defer></script><script src="/note/assets/js/1.51e4995c.js" defer></script><script src="/note/assets/js/95.5bd3b80e.js" defer></script>
  </body>
</html>
