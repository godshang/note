<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Kafka 实战 | 开发者笔记</title>
    <meta name="generator" content="VuePress 1.9.10">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/note/assets/css/0.styles.fa566ad0.css" as="style"><link rel="preload" href="/note/assets/js/app.e7654e9f.js" as="script"><link rel="preload" href="/note/assets/js/2.e810aa3c.js" as="script"><link rel="preload" href="/note/assets/js/1.07fc4d8c.js" as="script"><link rel="preload" href="/note/assets/js/112.c96d9beb.js" as="script"><link rel="prefetch" href="/note/assets/js/10.555b32ff.js"><link rel="prefetch" href="/note/assets/js/100.d020d8ee.js"><link rel="prefetch" href="/note/assets/js/101.7683a3d7.js"><link rel="prefetch" href="/note/assets/js/102.88714d09.js"><link rel="prefetch" href="/note/assets/js/103.233ddbe4.js"><link rel="prefetch" href="/note/assets/js/104.e433d6c3.js"><link rel="prefetch" href="/note/assets/js/105.fe2e4966.js"><link rel="prefetch" href="/note/assets/js/106.d239b033.js"><link rel="prefetch" href="/note/assets/js/107.3026af59.js"><link rel="prefetch" href="/note/assets/js/108.36315191.js"><link rel="prefetch" href="/note/assets/js/109.81c1c194.js"><link rel="prefetch" href="/note/assets/js/11.028a3c1c.js"><link rel="prefetch" href="/note/assets/js/110.f821be7e.js"><link rel="prefetch" href="/note/assets/js/111.e072da72.js"><link rel="prefetch" href="/note/assets/js/113.f62b712c.js"><link rel="prefetch" href="/note/assets/js/114.28d5802e.js"><link rel="prefetch" href="/note/assets/js/115.59b34590.js"><link rel="prefetch" href="/note/assets/js/116.e7563be8.js"><link rel="prefetch" href="/note/assets/js/117.2b203c5c.js"><link rel="prefetch" href="/note/assets/js/118.26adca05.js"><link rel="prefetch" href="/note/assets/js/119.54c5dd1e.js"><link rel="prefetch" href="/note/assets/js/12.1b649a19.js"><link rel="prefetch" href="/note/assets/js/120.b3a105c7.js"><link rel="prefetch" href="/note/assets/js/13.c8f31ead.js"><link rel="prefetch" href="/note/assets/js/14.f9046e47.js"><link rel="prefetch" href="/note/assets/js/15.3af5a383.js"><link rel="prefetch" href="/note/assets/js/16.9a3efa49.js"><link rel="prefetch" href="/note/assets/js/17.ef3ca875.js"><link rel="prefetch" href="/note/assets/js/18.831fa1a4.js"><link rel="prefetch" href="/note/assets/js/19.cfea4209.js"><link rel="prefetch" href="/note/assets/js/20.9c5bbcd6.js"><link rel="prefetch" href="/note/assets/js/21.3ad15aa3.js"><link rel="prefetch" href="/note/assets/js/22.45739dd6.js"><link rel="prefetch" href="/note/assets/js/23.0b3b321e.js"><link rel="prefetch" href="/note/assets/js/24.69ce0e0c.js"><link rel="prefetch" href="/note/assets/js/25.0730c414.js"><link rel="prefetch" href="/note/assets/js/26.2834d6fd.js"><link rel="prefetch" href="/note/assets/js/27.b67f9ce5.js"><link rel="prefetch" href="/note/assets/js/28.1b0ec007.js"><link rel="prefetch" href="/note/assets/js/29.c69a505d.js"><link rel="prefetch" href="/note/assets/js/3.922513d5.js"><link rel="prefetch" href="/note/assets/js/30.59c9f0f6.js"><link rel="prefetch" href="/note/assets/js/31.99a0ee4b.js"><link rel="prefetch" href="/note/assets/js/32.34fb1316.js"><link rel="prefetch" href="/note/assets/js/33.4c466f0a.js"><link rel="prefetch" href="/note/assets/js/34.11542871.js"><link rel="prefetch" href="/note/assets/js/35.f46213e9.js"><link rel="prefetch" href="/note/assets/js/36.191cc770.js"><link rel="prefetch" href="/note/assets/js/37.8d31cfbf.js"><link rel="prefetch" href="/note/assets/js/38.10058a9f.js"><link rel="prefetch" href="/note/assets/js/39.95b7b6ef.js"><link rel="prefetch" href="/note/assets/js/4.a1966589.js"><link rel="prefetch" href="/note/assets/js/40.aacc67a1.js"><link rel="prefetch" href="/note/assets/js/41.69d1900a.js"><link rel="prefetch" href="/note/assets/js/42.a10bf330.js"><link rel="prefetch" href="/note/assets/js/43.cca6ff22.js"><link rel="prefetch" href="/note/assets/js/44.90b90816.js"><link rel="prefetch" href="/note/assets/js/45.113abd6a.js"><link rel="prefetch" href="/note/assets/js/46.c428ba25.js"><link rel="prefetch" href="/note/assets/js/47.3fddf95f.js"><link rel="prefetch" href="/note/assets/js/48.cc7000a1.js"><link rel="prefetch" href="/note/assets/js/49.b873071f.js"><link rel="prefetch" href="/note/assets/js/5.b21639f8.js"><link rel="prefetch" href="/note/assets/js/50.fb0418b2.js"><link rel="prefetch" href="/note/assets/js/51.3933f89b.js"><link rel="prefetch" href="/note/assets/js/52.5d4b2e9e.js"><link rel="prefetch" href="/note/assets/js/53.b771539b.js"><link rel="prefetch" href="/note/assets/js/54.a0da92be.js"><link rel="prefetch" href="/note/assets/js/55.e3c32e70.js"><link rel="prefetch" href="/note/assets/js/56.c273a07a.js"><link rel="prefetch" href="/note/assets/js/57.d0e02578.js"><link rel="prefetch" href="/note/assets/js/58.72664a5f.js"><link rel="prefetch" href="/note/assets/js/59.d425fbf8.js"><link rel="prefetch" href="/note/assets/js/6.0299a03f.js"><link rel="prefetch" href="/note/assets/js/60.961047ab.js"><link rel="prefetch" href="/note/assets/js/61.dd024c7d.js"><link rel="prefetch" href="/note/assets/js/62.aa0ba217.js"><link rel="prefetch" href="/note/assets/js/63.e2a55dcc.js"><link rel="prefetch" href="/note/assets/js/64.30bf7f34.js"><link rel="prefetch" href="/note/assets/js/65.39726ca4.js"><link rel="prefetch" href="/note/assets/js/66.1addd97a.js"><link rel="prefetch" href="/note/assets/js/67.cc99e8a2.js"><link rel="prefetch" href="/note/assets/js/68.e278ab91.js"><link rel="prefetch" href="/note/assets/js/69.a9c2296f.js"><link rel="prefetch" href="/note/assets/js/7.84671687.js"><link rel="prefetch" href="/note/assets/js/70.51cd3ef1.js"><link rel="prefetch" href="/note/assets/js/71.78a7e100.js"><link rel="prefetch" href="/note/assets/js/72.d5f54084.js"><link rel="prefetch" href="/note/assets/js/73.2b2e81d3.js"><link rel="prefetch" href="/note/assets/js/74.026d5759.js"><link rel="prefetch" href="/note/assets/js/75.b315d618.js"><link rel="prefetch" href="/note/assets/js/76.e4402459.js"><link rel="prefetch" href="/note/assets/js/77.c492b51c.js"><link rel="prefetch" href="/note/assets/js/78.f13c15b5.js"><link rel="prefetch" href="/note/assets/js/79.6da0305c.js"><link rel="prefetch" href="/note/assets/js/80.10321fab.js"><link rel="prefetch" href="/note/assets/js/81.9daf45ce.js"><link rel="prefetch" href="/note/assets/js/82.17c606f7.js"><link rel="prefetch" href="/note/assets/js/83.68053253.js"><link rel="prefetch" href="/note/assets/js/84.cac1ee23.js"><link rel="prefetch" href="/note/assets/js/85.eb45d699.js"><link rel="prefetch" href="/note/assets/js/86.cdfbccd6.js"><link rel="prefetch" href="/note/assets/js/87.edc80e1b.js"><link rel="prefetch" href="/note/assets/js/88.d1cd3a58.js"><link rel="prefetch" href="/note/assets/js/89.ffd23af7.js"><link rel="prefetch" href="/note/assets/js/90.7ea29979.js"><link rel="prefetch" href="/note/assets/js/91.fa52ca7b.js"><link rel="prefetch" href="/note/assets/js/92.1aa72a1e.js"><link rel="prefetch" href="/note/assets/js/93.723b96db.js"><link rel="prefetch" href="/note/assets/js/94.e1a4317f.js"><link rel="prefetch" href="/note/assets/js/95.486c4f74.js"><link rel="prefetch" href="/note/assets/js/96.6f5bcf47.js"><link rel="prefetch" href="/note/assets/js/97.d196e0cc.js"><link rel="prefetch" href="/note/assets/js/98.3213f4f1.js"><link rel="prefetch" href="/note/assets/js/99.e73f1d6c.js"><link rel="prefetch" href="/note/assets/js/vendors~docsearch.200fb47e.js">
    <link rel="stylesheet" href="/note/assets/css/0.styles.fa566ad0.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/note/" class="home-link router-link-active"><!----> <span class="site-name">开发者笔记</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/note/" class="nav-link">
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/java/base/basic.html" class="nav-link">
  Java基础
</a></li><li class="dropdown-item"><!----> <a href="/note/java/collection/ArrayList.html" class="nav-link">
  Java集合框架
</a></li><li class="dropdown-item"><!----> <a href="/note/java/concurrent/Theory.html" class="nav-link">
  Java并发编程
</a></li><li class="dropdown-item"><!----> <a href="/note/java/jvm/memory.html" class="nav-link">
  JVM相关
</a></li><li class="dropdown-item"><!----> <a href="/note/java/nio/io.html" class="nav-link">
  Java NIO相关
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据存储" class="dropdown-title"><span class="title">数据存储</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据存储" class="mobile-dropdown-title"><span class="title">数据存储</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/storage/database/mysql.html" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/note/storage/redis/redis-question.html" class="nav-link">
  Redis
</a></li><li class="dropdown-item"><!----> <a href="/note/storage/mq/kafka-intro.html" class="nav-link">
  消息队列
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="框架" class="dropdown-title"><span class="title">框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="框架" class="mobile-dropdown-title"><span class="title">框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/framework/spring-framework/spring-framework-intro.html" class="nav-link">
  Spring框架
</a></li><li class="dropdown-item"><!----> <a href="/note/framework/netty/netty-business-logic.html" class="nav-link">
  Netty
</a></li><li class="dropdown-item"><!----> <a href="/note/framework/apollo/setup-debug-enviroment.html" class="nav-link">
  Apollo源码分析
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="架构" class="dropdown-title"><span class="title">架构</span> <span class="arrow down"></span></button> <button type="button" aria-label="架构" class="mobile-dropdown-title"><span class="title">架构</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/arch/system-design/01-scale-from-zero.html" class="nav-link">
  系统设计
</a></li><li class="dropdown-item"><!----> <a href="/note/arch/case-study/rate-limiter.html" class="nav-link">
  案例
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/note/" class="nav-link">
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Java" class="dropdown-title"><span class="title">Java</span> <span class="arrow down"></span></button> <button type="button" aria-label="Java" class="mobile-dropdown-title"><span class="title">Java</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/java/base/basic.html" class="nav-link">
  Java基础
</a></li><li class="dropdown-item"><!----> <a href="/note/java/collection/ArrayList.html" class="nav-link">
  Java集合框架
</a></li><li class="dropdown-item"><!----> <a href="/note/java/concurrent/Theory.html" class="nav-link">
  Java并发编程
</a></li><li class="dropdown-item"><!----> <a href="/note/java/jvm/memory.html" class="nav-link">
  JVM相关
</a></li><li class="dropdown-item"><!----> <a href="/note/java/nio/io.html" class="nav-link">
  Java NIO相关
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据存储" class="dropdown-title"><span class="title">数据存储</span> <span class="arrow down"></span></button> <button type="button" aria-label="数据存储" class="mobile-dropdown-title"><span class="title">数据存储</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/storage/database/mysql.html" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/note/storage/redis/redis-question.html" class="nav-link">
  Redis
</a></li><li class="dropdown-item"><!----> <a href="/note/storage/mq/kafka-intro.html" class="nav-link">
  消息队列
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="框架" class="dropdown-title"><span class="title">框架</span> <span class="arrow down"></span></button> <button type="button" aria-label="框架" class="mobile-dropdown-title"><span class="title">框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/framework/spring-framework/spring-framework-intro.html" class="nav-link">
  Spring框架
</a></li><li class="dropdown-item"><!----> <a href="/note/framework/netty/netty-business-logic.html" class="nav-link">
  Netty
</a></li><li class="dropdown-item"><!----> <a href="/note/framework/apollo/setup-debug-enviroment.html" class="nav-link">
  Apollo源码分析
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="架构" class="dropdown-title"><span class="title">架构</span> <span class="arrow down"></span></button> <button type="button" aria-label="架构" class="mobile-dropdown-title"><span class="title">架构</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/arch/system-design/01-scale-from-zero.html" class="nav-link">
  系统设计
</a></li><li class="dropdown-item"><!----> <a href="/note/arch/case-study/rate-limiter.html" class="nav-link">
  案例
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>消息队列</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/note/storage/mq/kafka-intro.html" class="sidebar-link">Kafka详解</a></li><li><a href="/note/storage/mq/kafka-question.html" aria-current="page" class="active sidebar-link">Kafka常见问题</a></li><li><a href="/note/storage/mq/rmq-intro.html" class="sidebar-link">RocketMQ详解</a></li><li><a href="/note/storage/mq/mq-question.html" class="sidebar-link">MQ常见问题</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="kafka-实战"><a href="#kafka-实战" class="header-anchor">#</a> Kafka 实战</h1> <h2 id="producer无消息丢失配置"><a href="#producer无消息丢失配置" class="header-anchor">#</a> producer无消息丢失配置</h2> <p>Kafka Java版本的producer采用异步发送机制。send方法仅仅把消息放入缓冲区，由一个专属I/O线程负责从缓冲区中提取消息并封装仅消息batch中，然后发送出去。这个过程中存在数据丢失的窗口：若I/O线程发送之前producer崩溃，则存储缓冲区中的消息全部丢失了。</p> <p>producer另一个问题就是消息的乱序。假设客户端一次发送两条消息到相同的分区，若此时由于某些原因，比如瞬时的网络抖动，导致第一条消息未发送成功，同时Kafka又配置了重试机制以及<code>max.in.flight.requests.per.connection</code>大于1（默认值是5），那么producer重试第一条消息成功后，第一条消息在日志中的位置反而位于第二条消息之后，这就造成了消息的乱序，而很多场景中都有事件强顺序保证的要求。</p> <p>使用同步发送可以规避第一个问题，但性能会很差，并不推荐在实际场景中使用。因此最后能够使用异步方式的同时还能有效避免数据丢失，即使producer崩溃也不会有问题。</p> <p>producer端无消息丢失配置如下：</p> <ul><li>block.on.buffer.full = true</li> <li>acks = all or -1</li> <li>retries = Integer.MAX_VALUE</li> <li>max.in.flight.requests.per.connection = 1</li> <li>使用带回调机制的send发送消息，即 KafkaProducer.send(record, callback)</li> <li>Callback逻辑中显式地关闭producer，使用 close(0)</li> <li>unclean.leader.election.enable = false</li> <li>replication.factor = 3</li> <li>min.insync.replicas = 2</li> <li>replication.factor &gt; min.insync.replicas</li> <li>enable.auto.commit = false</li></ul> <p>下面分别从producer端和broker端分别讨论上述参数这样设置的含义。</p> <h3 id="producer端配置"><a href="#producer端配置" class="header-anchor">#</a> producer端配置</h3> <p><strong>block.on.buffer.full = true</strong></p> <p>实际上这个参数在0.9.0.0版本已经被标记为deprecated，并使用<code>max.block.ms</code>参数替代，但这里还是推荐用户显示地设置它为<code>true</code>，使得内存缓冲区被填满时producer处于阻塞状态并停止接收新的消息而不是抛出异常；否则producer生产速度过快会导致耗尽缓冲区。新版本（0.10.0.0之后）可以不用理会这个参数，转而设置<code>max.block.ms</code>即可。</p> <p><strong>acks = all</strong></p> <p>设置acks为all很容易理解，即必须要等到所有follower都响应了发送消息才能被认为提交成功，这是producer端最强程度的持久化保证。</p> <p><strong>retries = Integer.MAX_VALUE</strong></p> <p>设置成MAX_VALUE有些极端，但其实想表达的是producer要开启无限重试。用户不必担心producer会重试那些肯定无法恢复的错误，当前producer只会城市那些可恢复的异常情况，所以放心地设置一个比较大的值通常能很好地保证消息不丢失。</p> <p><strong>max.in.flight.requests.per.connection = 1</strong></p> <p>设置该参数为1主要是为了防止topic同分区下的消息乱序问题。这个参数的实际效果其实限制了producer在单个broker连接上能够发送的未响应请求的数量。因此，如果设置成1，则producer在某个broker发送响应之前将无法再给该broker发送PRODUCE请求。</p> <p><strong>使用带回调机制的send</strong></p> <p>不要使用KafkaProducer中单参数的send方法，因为该send调用仅仅是把消息发出而不会理会消息发送的结果。如果消息发送失败，该方法不会得到任何通知，故可能造成数据的丢失，实际环境中一定要使用带回调机制的send版本。</p> <p><strong>Callback逻辑中显示立即关闭producer</strong></p> <p>在Callback的失败处理逻辑中显示调用KafkaProducer.close(0)，这样做的目的是为了处理消息的乱序问题。若不使用close(0)，默认情况下producer会被允许将未完成的消息发送出去，这样就有可能造成消息乱序。</p> <h3 id="broker端配置"><a href="#broker端配置" class="header-anchor">#</a> broker端配置</h3> <p><strong>unclean.leader.election.enable = false</strong></p> <p>关闭unclean leader选举，即不允许非ISR中的副本被选举为leader，从而避免broker端音日志水位截断而造成的消息丢失。</p> <p><strong>replication.faction &gt;= 3</strong></p> <p>设置成3主要是参考Hadoop及业界通用的三副本原则，其实这里主要想强调的一定使用多个副本来保存分区的消息。</p> <p><strong>min.insync.replicas &gt; 1</strong></p> <p>用于控制某条消息至少被写入到ISR中的多少个副本才算成功。设置成大于1是为了提升producer端发送语义的持久性。记住只有在producer端acks被设置成all或-1时，这个参数才有意义。在实际使用时，不要使用默认值。</p> <p><strong>确保replication.factor &gt; min.insync.replicas</strong></p> <p>若两者相等，那么只要有一个副本挂掉，分区就无法正常工作，虽然有很高的持久性但可用性被极大地降低了。推荐配置成replication.factor = min.insync.replicas + 1。</p> <h2 id="q1-kafka是如何保障数据不丢失的"><a href="#q1-kafka是如何保障数据不丢失的" class="header-anchor">#</a> Q1：Kafka是如何保障数据不丢失的？</h2> <p>该问题已经成为了Kafka面试的惯例，如同Java的HashMap，属于高频出现的面试问题。那么，我们该怎么理解这个问题呢？问题是Kafka如何保障数据不丢失，即Kafka的Broker提供了什么机制保证数据不丢失的。其实对于Kafka的Broker而言，Kafka 的复制机制和分区的多副本架构是Kafka 可靠性保证的核心。把消息写入多个副本可以使Kafka 在发生崩溃时仍能保证消息的持久性。搞清楚了问题的核心，再来看一下该怎么回答这个问题：主要包括三个方面</p> <blockquote><p>1.Topic 副本因子个数：replication.factor &gt;= 3
2.同步副本列表(ISR)：min.insync.replicas = 2
3.禁用unclean选举：unclean.leader.election.enable=false</p></blockquote> <p>下面将会逐步分析上面的三个配置：</p> <p><strong>副本因子</strong></p> <p>Kafka的topic是可以分区的，并且可以为分区配置多个副本，该配置可以通过replication.factor参数实现。Kafka中的分区副本包括两种类型：领导者副本（Leader Replica）和追随者副本（Follower Replica)，每个分区在创建时都要选举一个副本作为领导者副本，其余的副本自动变为追随者副本。在 Kafka 中，追随者副本是不对外提供服务的，也就是说，任何一个追随者副本都不能响应消费者和生产者的读写请求。所有的请求都必须由领导者副本来处理。换句话说，所有的读写请求都必须发往领导者副本所在的 Broker，由该 Broker 负责处理。追随者副本不处理客户端请求，它唯一的任务就是从领导者副本异步拉取消息，并写入到自己的提交日志中，从而实现与领导者副本的同步。一般来说，副本设为3可以满足大部分的使用场景，也有可能是5个副本(比如银行)。如果副本因子为N，那么在N-1个broker 失效的情况下，仍然能够从主题读取数据或向主题写入数据。所以，更高的副本因子会带来更高的可用性、可靠性和更少的故障。另一方面，副本因子N需要至少N个broker ，而且会有N个数据副本，也就是说它们会占用N倍的磁盘空间。实际生产环境中一般会在可用性和存储硬件之间作出权衡。除此之外，副本的分布同样也会影响可用性。默认情况下，Kafka会确保分区的每个副本分布在不同的Broker上，但是如果这些Broker在同一个机架上，一旦机架的交换机发生故障，分区就会不可用。所以建议把Broker分布在不同的机架上，可以使用broker.rack参数配置Broker所在机架的名称。</p> <p><strong>同步副本列表</strong></p> <p>In-sync replica(ISR)称之为同步副本，ISR中的副本都是与Leader进行同步的副本，所以不在该列表的follower会被认为与Leader是不同步的。那么，ISR中存在是什么副本呢？首先可以明确的是：Leader副本总是存在于ISR中。而follower副本是否在ISR中，取决于该follower副本是否与Leader副本保持了“同步”。Kafka的broker端有一个参数replica.lag.time.max.ms, 该参数表示follower副本滞后与Leader副本的最长时间间隔，默认是10秒。这就意味着，只要follower副本落后于leader副本的时间间隔不超过10秒，就可以认为该follower副本与leader副本是同步的，所以哪怕当前follower副本落后于Leader副本几条消息，只要在10秒之内赶上Leader副本，就不会被踢出出局。可以看出ISR是一个动态的，所以即便是为分区配置了3个副本，还是会出现同步副本列表中只有一个副本的情况(其他副本由于不能够与leader及时保持同步，被移出ISR列表)。如果这个同步副本变为不可用，我们必须在可用性和一致性之间作出选择(CAP理论)。根据Kafka 对可靠性保证的定义，消息只有在被写入到所有同步副本之后才被认为是已提交的。但如果这里的“所有副本”只包含一个同步副本，那么在这个副本变为不可用时，数据就会丢失。如果要确保已提交的数据被写入不止一个副本，就需要把最小同步副本数量设置为大一点的值。对于一个包含3 个副本的主题分区，如果min.insync.replicas=2，那么至少要存在两个同步副本才能向分区写入数据。如果进行了上面的配置，此时必须要保证ISR中至少存在两个副本，如果ISR中的副本个数小于2，那么Broker就会停止接受生产者的请求。尝试发送数据的生产者会收到NotEnoughReplicasException异常，消费者仍然可以继续读取已有的数据。</p> <p><strong>禁用unclean选举</strong></p> <p>选择一个同步副本列表中的分区作为leader 分区的过程称为clean leader election。注意，这里要与在非同步副本中选一个分区作为leader分区的过程区分开，在非同步副本中选一个分区作为leader的过程称之为unclean leader election。由于ISR是动态调整的，所以会存在ISR列表为空的情况，通常来说，非同步副本落后 Leader 太多，因此，如果选择这些副本作为新 Leader，就可能出现数据的丢失。毕竟，这些副本中保存的消息远远落后于老 Leader 中的消息。在 Kafka 中，选举这种副本的过程可以通过Broker 端参数unclean.leader.election.enable控制是否允许 Unclean 领导者选举。开启 Unclean 领导者选举可能会造成数据丢失，但好处是，它使得分区 Leader 副本一直存在，不至于停止对外提供服务，因此提升了高可用性。反之，禁止 Unclean Leader 选举的好处在于维护了数据的一致性，避免了消息丢失，但牺牲了高可用性。分布式系统的CAP理论说的就是这种情况。不幸的是，unclean leader election的选举过程仍可能会造成数据的不一致，因为同步副本并不是完全同步的。由于复制是异步完成的，因此无法保证follower可以获取最新消息。比如Leader分区的最后一条消息的offset是100，此时副本的offset可能不是100，这受到两个参数的影响：</p> <ul><li>replica.lag.time.max.ms：同步副本滞后与leader副本的时间</li> <li>zookeeper.session.timeout.ms：与zookeeper会话超时时间</li></ul> <p>简而言之，如果我们允许不同步的副本成为leader，那么就要承担丢失数据和出现数据不一致的风险。如果不允许它们成为leader，那么就要接受较低的可用性，因为我们必须等待原先的首领恢复到可用状态。关于unclean选举，不同的场景有不同的配置方式。对数据质量和数据一致性要求较高的系统会禁用这种unclean的leader选举(比如银行)。如果在可用性要求较高的系统里，比如实时点击流分析系统， 一般不会禁用unclean的leader选举。</p> <h2 id="q2-如何解决kafka数据丢失问题"><a href="#q2-如何解决kafka数据丢失问题" class="header-anchor">#</a> Q2：如何解决Kafka数据丢失问题？</h2> <p>你可能会问：这个问题跟Q1有什么区别呢？其实一般在面试问题中可以理解成一个问题。之所以在这里做出区分，是因为两者的解决方式不一样。Q1问题是从Kafka的Broker侧来看待数据丢失的问题，而Q2是从Kafka的生产者与消费者的角度来看待数据丢失的问题。先来看一下如何回答这个问题，主要包括两个方面：</p> <p>Producer</p> <ul><li>retries=Long.MAX_VALUE设置 retries 为一个较大的值。这里的 retries 同样是 Producer 的参数，对应前面提到的 Producer 自动重试。当出现网络的瞬时抖动时，消息发送可能会失败，此时配置了 retries &gt; 0 的 Producer 能够自动重试消息发送，避免消息丢失。</li> <li>acks=all设置 acks = all。acks 是 Producer 的一个参数，代表了你对“已提交”消息的定义。如果设置成 all，则表明所有副本 Broker 都要接收到消息，该消息才算是“已提交”。这是最高等级的“已提交”定义。</li> <li>max.in.flight.requests.per.connections=1该参数指定了生产者在收到服务器晌应之前可以发送多少个消息。它的值越高，就会占用越多的内存，不过也会提升吞吐量。把它设为1 可以保证消息是按照发送的顺序写入服务器的，即使发生了重试。</li> <li>Producer要使用带有回调通知的API，也就是说不要使用 producer.send(msg)，而要使用 producer.send(msg, callback)。</li> <li>其他错误处理使用生产者内置的重试机制，可以在不造成消息丢失的情况下轻松地处理大部分错误，不过 仍然需要处理其他类型的错误，例如消息大小错误、序列化错误等等。</li></ul> <p>Consumer</p> <ul><li>禁用自动提交：enable.auto.commit=false</li> <li>消费者处理完消息之后再提交offset</li> <li>配置auto.offset.reset这个参数指定了在没有偏移量可提交时(比如消费者第l次启动时)或者请求的偏移量在broker上不存在时(比如数据被删了)，消费者会做些什么。这个参数有两种配置。一种是earliest：消费者会从分区的开始位置读取数据，不管偏移量是否有效，这样会导致消费者读取大量的重复数据，但可以保证最少的数据丢失。一种是latest(默认)，如果选择了这种配置， 消费者会从分区的末尾开始读取数据，这样可以减少重复处理消息，但很有可能会错过一些消息。</li></ul> <h2 id="q3-kafka可以保障永久不丢失数据吗"><a href="#q3-kafka可以保障永久不丢失数据吗" class="header-anchor">#</a> Q3：Kafka可以保障永久不丢失数据吗？</h2> <p>上面分析了一些保障数据不丢失的措施，在一定程度上可以避免数据的丢失。但是请注意：Kafka 只对“已提交”的消息（committed message）做有限度的持久化保证。所以说，Kafka不能够完全保证数据不丢失，需要做出一些权衡。首先，要理解什么是已提交的消息，当 Kafka 的若干个 Broker 成功地接收到一条消息并写入到日志文件后，它们会告诉生产者程序这条消息已成功提交。此时，这条消息在 Kafka 看来就正式变为已提交消息了。所以说无论是ack=all，还是ack=1,不论哪种情况，Kafka 只对已提交的消息做持久化保证这件事情是不变的。其次，要理解有限度的持久化保证，也就是说 Kafka 不可能保证在任何情况下都做到不丢失消息。必须保证Kafka的Broker是可用的，换句话说，假如消息保存在 N 个 Kafka Broker 上，那么这个前提条件就是这 N 个 Broker 中至少有 1 个存活。只要这个条件成立，Kafka 就能保证你的这条消息永远不会丢失。总结一下，Kafka 是能做到不丢失消息的，只不过这些消息必须是已提交的消息，而且还要满足一定的条件。</p> <h2 id="q4-如何保障kafka中的消息是有序的"><a href="#q4-如何保障kafka中的消息是有序的" class="header-anchor">#</a> Q4：如何保障Kafka中的消息是有序的？</h2> <p>首先需要明确的是：Kafka的主题是分区有序的，如果一个主题有多个分区，那么Kafka会按照key将其发送到对应的分区中，所以，对于给定的key，与其对应的record在分区内是有序的。Kafka可以保证同一个分区里的消息是有序的，即生产者按照一定的顺序发送消息，Broker就会按照这个顺序将他们写入对应的分区中，同理，消费者也会按照这个顺序来消费他们。在一些场景下，消息的顺序是非常重要的。比如，先存钱再取钱与先取钱再存钱是截然不同的两种结果。上面的问题中提到一个参数max.in.flight.requests.per.connections=1,该参数的作用是在重试次数大于等于1时，保证数据写入的顺序。如果该参数不为1，那么当第一个批次写入失败时，第二个批次写入成功，Broker会重试写入第一个批次，如果此时第一个批次重试写入成功，那么这两个批次消息的顺序就反过来了。一般来说，如果对消息的顺序有要求，那么在为了保障数据不丢失，需要先设置发送重试次数retries&gt;0,同时需要把max.in.flight.requests.per.connections参数设为1，这样在生产者尝试发送第一批消息时，就不会有其他的消息发送给broker，虽然会影响吞吐量，但是可以保证消息的顺序。除此之外，还可以使用单分区的Topic，但是会严重影响吞吐量。</p> <h2 id="q5-如何确定合适的kafka主题的分区数量"><a href="#q5-如何确定合适的kafka主题的分区数量" class="header-anchor">#</a> Q5：如何确定合适的Kafka主题的分区数量？</h2> <p>选择合适的分区数量可以达到高度并行读写和负载均衡的目的，在分区上达到均衡负载是实现吞吐量的关键。需要根据每个分区的生产者和消费者的期望吞吐量进行估计。</p> <p>举个栗子：假设期望读取数据的速率(吞吐量)为1GB/Sec，而一个消费者的读取速率为50MB/Sec，此时至少需要20个分区以及20个消费者(一个消费者组)。同理，如果期望生产数据的速率为1GB/Sec，而每个生产者的生产速率为100MB/Sec，此时就需要有10个分区。在这种情况下，如果设置20个分区，既可以保障1GB/Sec的生产速率，也可以保障消费者的吞吐量。通常需要将分区的数量调整为消费者或者生产者的数量，只有这样才可以同时实现生产者和消费者的吞吐量。</p> <p>一个简单的计算公式为：分区数 = max(生产者数量，消费者数量)</p> <ul><li>生产者数量=整体生产吞吐量/每个生产者对单个分区的最大生产吞吐量</li> <li>消费者数量=整体消费吞吐量/每个消费者从单个分区消费的最大吞吐量</li></ul> <h2 id="q6-如何调整生产环境中kafka主题的分区数量"><a href="#q6-如何调整生产环境中kafka主题的分区数量" class="header-anchor">#</a> Q6：如何调整生产环境中Kafka主题的分区数量？</h2> <p>需要注意的是：当我们增加主题的分区数量时，会违背同一个key进行同一个分区的事实。我们可以创建一个新的主题，使得该主题有更多的分区数，然后暂停生产者，将旧的主题中的数据复制到新的主题中，然后将消费者和生产者切换到新的主题，操作起来会非常棘手。</p> <h2 id="q7-如何重平衡kafka集群"><a href="#q7-如何重平衡kafka集群" class="header-anchor">#</a> Q7:如何重平衡Kafka集群？</h2> <p>在下面情况发生时，需要重平衡集群：</p> <ul><li>主题分区在整个集群里的不均衡分布造成了集群负载的不均衡。</li> <li>broker离线造成分区不同步。</li> <li>新加入的broker 需要从集群里获得负载。</li></ul> <p>使用kafka-reassign-partitions.sh命令进行重平衡</p> <h2 id="q8-如何查看消费者组是否存在滞后消费"><a href="#q8-如何查看消费者组是否存在滞后消费" class="header-anchor">#</a> Q8:如何查看消费者组是否存在滞后消费？</h2> <p>我们可以使用kafka-consumer-groups.sh命令进行查看，比如：</p> <div class="language- extra-class"><pre class="language-text"><code>$ bin/kafka-consumer-groups.sh --bootstrap-server cdh02:9092 --describe --group my-group
## 会显示下面的一些指标信息
TOPIC PARTITION CURRENT-OFFSET LOG-END-OFFSET   LAG          CONSUMER-ID HOST CLIENT-ID
主题   分区       当前offset      LEO           滞后消息数       消费者id     主机   客户端id
</code></pre></div><p>一般情况下，如果运行良好，CURRENT-OFFSET的值会与LOG-END-OFFSET的值非常接近。通过这个命令可以查看哪个分区的消费出现了滞后。</p> <h2 id="q9-什么是isr"><a href="#q9-什么是isr" class="header-anchor">#</a> Q9：什么是ISR？</h2> <p>ISR是Kafka集群动态维护的一组同步副本集，每个topic分区都有自己的ISR列表，ISR中的所有副本都与leader副本保持同步状态，并且leader副本总是包含在ISR中的，只有ISR中的副本才有资格被选举为leader。</p> <p>ISR中关于同步的判定，在新老版本之中不同。在0.9.0.0版本之前，使用<code>replica.lag.max.messages</code>参数设置follower副本落后与leader副本的消息数，一旦超过了这个消息数就认为该follower副本为不同步的状态，从而被Kafka踢出ISR。</p> <p>可能follower与leader不同步的原因主要有3个：</p> <ul><li>请求速度追不上：follower副本在一段时间内都无法追上leader副本端的消息接收速度，比如follower副本所在的broker的网络I/O开销过大导致备份消息的速度持续慢于从leader处获取消息的速度。</li> <li>进程卡住：follower在一段时间无法向leader请求数据，比如GC或程序bug等。</li> <li>新创建的副本：如果用户增加了副本数，那么新创建的follower副本在启动后全力追赶leader进度，在追赶进度这段时间内通常都是与leader不同步的。</li></ul> <p><code>replica.lag.max.messages</code>是用于检测第一种情况的。<code>replica.lag.time.max.ms</code>用于检测另外联众情况，表示超过设定的时间则被视为不同步，就会被踢出ISR。</p> <p>0.9.0.0版本之前的这种ISR设计方案有一些缺陷，比如突然有一波消息生产的瞬时高峰流量，是得消息数大于等于了<code>replica.lang.max.messages</code>的值，此时follower副本就会被认为与leader副本不同步，从而被踢出ISR。然而follower副本所在broker实际上都处于存活状态且没有任何性能问题，等到追上leader的LEO就重新加入了ISR——于是就出现了它们不断被踢出ISR，然后又重新加回ISR的情况。</p> <p>另外，<code>replica.lag.max.messages</code>这个参数是全局的，如果设置过大，不同topic的流量差异又非常大的情况，就会出现低流量的topic要花费相当长的时间才会被Kafka辨别出滞后。</p> <p>0.9.0.0版本之后，Kafka去掉了<code>replica.lag.max.messages</code>这个参数，改用统一的参数同时检测由于慢以及进程卡壳而导致的之后，即follower副本落后leader副本的时间间隔，这个唯一的参数就是<code>replica.lag.time.max.ms</code>，默认值是10秒。</p> <h2 id="q10-controller是做什么的"><a href="#q10-controller是做什么的" class="header-anchor">#</a> Q10：Controller是做什么的？</h2> <p>每个Kafka集群任意时刻都只能有一个controller，集群启动时都会参与controller的竞选。Controller包括如下职责：</p> <ul><li>更新集群元数据信息</li> <li>创建topic</li> <li>删除topic</li> <li>分区重分配</li> <li>preferred leader副本选举</li> <li>topic分区扩展</li> <li>broker加入集群</li> <li>broker崩溃</li> <li>受控关闭</li> <li>controller leader选举</li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/note/storage/mq/kafka-intro.html" class="prev">
        Kafka详解
      </a></span> <span class="next"><a href="/note/storage/mq/rmq-intro.html">
        RocketMQ详解
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/note/assets/js/app.e7654e9f.js" defer></script><script src="/note/assets/js/2.e810aa3c.js" defer></script><script src="/note/assets/js/1.07fc4d8c.js" defer></script><script src="/note/assets/js/112.c96d9beb.js" defer></script>
  </body>
</html>
